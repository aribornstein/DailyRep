<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PushUps 100</title>

  <!-- Ionic (no build step): https://ionicframework.com/docs/intro/cdn -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/dist/ionic/ionic.esm.js"></script>
  <script nomodule src="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/dist/ionic/ionic.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/css/ionic.bundle.css" />

  <style>
    :root {
      --ion-color-primary: #ff9500;
      --ion-color-primary-rgb: 255,149,0;
      --ion-background-color: #0b0f14;
      --ion-text-color: #e7eef7;
    }
    ion-content {
      --background: linear-gradient(180deg, #06080c 0%, #0b0f14 40%, #0b0f14 100%);
    }
    .muted { opacity: 0.75; }
    .bigNumber { font-size: 64px; font-weight: 800; line-height: 1; }
    .center { text-align: center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .cardDark {
      --background: rgba(18, 24, 38, 0.9);
      border: 1px solid rgba(34,48,71,.8);
    }
    .chipOk { --background: rgba(124,255,107,.12); }
    .chipWarn { --background: rgba(255,209,102,.12); }
    .chipBad { --background: rgba(255,92,122,.12); }
    .stickyBottom {
      position: sticky;
      bottom: 0;
      z-index: 5;
      background: rgba(11,15,20,.85);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(34,48,71,.6);
      padding: 10px 12px;
    }

    /* Training screen (middle-picture vibe) */
    .trainingWrap {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .trainingTop {
      padding: 14px 16px 8px;
    }
    .trainingTopRow {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
    }
    .trainingStrip {
      padding: 10px 12px;
      margin: 10px 16px 0;
      border: 1px solid rgba(34,48,71,.8);
      border-radius: 14px;
      background: rgba(18,24,38,.75);
      display: flex;
      gap: 10px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .setPill {
      flex: 0 0 auto;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(34,48,71,.9);
      background: #0b1220;
      color: rgba(231,238,247,.9);
      font-weight: 700;
      font-size: 13px;
    }
    .setPill.active {
      border-color: rgba(255,149,0,.9);
      box-shadow: 0 0 0 3px rgba(255,149,0,.18);
      color: white;
    }
    .setPill.done {
      border-color: rgba(124,255,107,.75);
      color: rgba(124,255,107,.95);
    }

    .tapArea {
      flex: 1;
      margin: 14px 16px;
      border-radius: 20px;
      border: 1px solid rgba(34,48,71,.85);
      background: linear-gradient(180deg, rgba(255,149,0,.22), rgba(18,24,38,.65));
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      position: relative;
      overflow: hidden;
    }
    .tapArea:active { transform: scale(0.995); }
    .tapInner { text-align: center; padding: 14px; }
    .tapHint { margin-top: 10px; font-weight: 700; letter-spacing: .06em; opacity: .75; }
    .tapMeta {
      margin-top: 10px;
      font-size: 13px;
      opacity: .78;
    }
    .tapCount {
      font-size: 92px;
      font-weight: 900;
      line-height: 1;
    }

    .trainingBottom {
      padding: 10px 16px 16px;
      border-top: 1px solid rgba(34,48,71,.6);
      background: rgba(11,15,20,.85);
      backdrop-filter: blur(10px);
    }
    .bottomRow {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #finishSetBtn {
      flex: 1;
      width: 100%;
    }
    /* restBadge removed */
    .smallBtn {
      --border-radius: 14px;
    }

    /* Hide scrollbars for the strip on iOS */
    .trainingStrip::-webkit-scrollbar { display: none; }

    /* Plan list highlight for current session */
    .planCurrent {
      border-left: 3px solid var(--ion-color-primary);
      background: rgba(255,149,0,.08);
    }

    /* Mini test panel (hidden) */
    #testLog { display:none; }
  </style>
</head>
<body>
  <ion-app>
    <ion-header translucent="true">
      <ion-toolbar color="dark">
        <ion-title>
          <span style="font-weight:800">PushUps</span>
          <span style="color:var(--ion-color-primary); font-weight:800; margin-left:6px">100</span>
        </ion-title>
        <ion-buttons slot="end">
          <ion-button id="settingsBtn" fill="clear">
            <ion-icon name="settings-outline"></ion-icon>
          </ion-button>
        </ion-buttons>
      </ion-toolbar>

      <ion-toolbar color="dark">
        <ion-segment value="workout" id="tabSeg">
          <ion-segment-button value="workout">
            <ion-label>Workout</ion-label>
          </ion-segment-button>
          <ion-segment-button value="history">
            <ion-label>History</ion-label>
          </ion-segment-button>
        </ion-segment>
      </ion-toolbar>
    </ion-header>

    <ion-content fullscreen="true" scroll-y="true" style="--overflow:auto; overscroll-behavior:contain;">
      <!-- WORKOUT VIEW -->
      <div id="viewWorkout">
        <ion-card class="cardDark">
          <ion-card-header>
            <ion-card-title>
              Day <span id="planDay">—</span>
              <span class="muted" style="font-size:14px; font-weight:600; margin-left:8px">Plan: <span id="planBadge">—</span></span>
            </ion-card-title>
            <ion-card-subtitle class="muted">Your daily target (top + back-offs)</ion-card-subtitle>
          </ion-card-header>

          <ion-card-content>
            <div class="center" style="margin: 10px 0 6px;">
              <div class="bigNumber" id="toGo">—</div>
              <div class="muted" style="font-weight:700; letter-spacing:.06em;">PUSH-UPS TO 100 MAX REP</div>
              <div style="margin-top:8px" class="mono muted" id="targetLine">—</div>
            </div>

            <ion-item lines="none" style="--background: transparent; margin-top:10px">
              <ion-label class="muted">Training progress</ion-label>
              <ion-progress-bar id="volBar" value="0" color="primary"></ion-progress-bar>
            </ion-item>
            <div class="muted" style="font-size:12px; margin-top:6px">Target volume: <span id="volPct">—</span> of <span id="volGoal">—</span></div>
          </ion-card-content>
        </ion-card>

        <ion-card class="cardDark">
          <ion-card-header>
            <ion-card-title>Plan overview</ion-card-title>
            <ion-card-subtitle class="muted"><span id="planSubText">Sessions remaining to day 100</span></ion-card-subtitle>
          </ion-card-header>
          <ion-card-content>
            <div class="muted">Sessions left: <span id="sessionsLeft">—</span></div>
            <div class="mono muted" id="planPreview" style="margin-top:8px">Plan not available</div>
                <ion-button expand="block" fill="outline" color="primary" id="viewPlanBtn" style="margin-top:12px">View full plan</ion-button>
            </ion-card-content>
            </ion-card>

            <ion-card class="cardDark">
            <ion-card-header>
                <ion-card-title>Today</ion-card-title>
                <ion-card-subtitle class="muted">Session data is auto-saved</ion-card-subtitle>
            </ion-card-header>
            <ion-card-content>
                <div class="muted" style="margin-bottom:8px">Last Completed Sets</div>
                <div class="mono" id="setsDisplay">—</div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
                <ion-chip id="doneChip" class="chipWarn"><ion-label>Done: —</ion-label></ion-chip>
                <ion-chip class="chipWarn"><ion-label>Total: <span id="todayTotal">—</span></ion-label></ion-chip>
                <ion-chip class="chipWarn"><ion-label>PR total: <span id="bestTotal">—</span></ion-label></ion-chip>
                </div>
            </ion-card-content>
            </ion-card>

            <div class="stickyBottom">
            <div style="display:flex; gap:10px;">
                <ion-button expand="block" color="primary" id="startTrainingBtn" style="flex:1">
                <ion-icon slot="start" name="fitness-outline"></ion-icon>
                Start training
                </ion-button>
                <ion-button expand="block" fill="outline" color="primary" id="sessionBtn" style="flex:1">
                <ion-icon slot="start" name="trophy-outline"></ion-icon>
                Session / record
                </ion-button>
            </div>
        </div>
      </div>

      <!-- HISTORY VIEW -->
      <div id="viewHistory" style="display:none">
        <ion-list inset="true" id="historyList"></ion-list>
        <div style="padding: 0 16px 18px" class="muted">Tip: tap a workout to load it back into the Workout tab.</div>
      </div>

      <!-- SETTINGS MODAL -->
      <ion-modal id="settingsModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Settings</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeSettings" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <ion-list inset="true">
            <ion-item>
              <ion-label position="stacked">Starting Max reps (one set)</ion-label>
              <ion-input id="maxReps" type="number" min="1" value="30"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Top set start % (fixed)</ion-label>
              <ion-input id="startPercent" type="text" value="—" disabled></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Intensity profile (fixed)</ion-label>
              <ion-input id="drops" value="85,80,75,70,65" disabled></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Rest timer (seconds)</ion-label>
              <ion-input id="rest" type="number" min="30" step="5" value="90"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label>Beep on each rep</ion-label>
              <ion-toggle id="beepToggle" checked="true"></ion-toggle>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Plan length (days)</ion-label>
              <ion-input id="planDays" type="number" min="1" max="365" value="100"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Goal max reps (single set)</ion-label>
              <ion-input id="goalVolume" type="number" min="1" max="1000" value="100"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Rounding</ion-label>
              <ion-select id="rounding" value="nearest">
                <ion-select-option value="down">Down</ion-select-option>
                <ion-select-option value="nearest">Nearest</ion-select-option>
                <ion-select-option value="up">Up</ion-select-option>
              </ion-select>
            </ion-item>
          </ion-list>

          <div style="padding: 0 16px 16px">
            <ion-button expand="block" color="primary" id="saveSettingsBtn">Save settings</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="startTodayBtn" style="margin-top:10px">Start / reset plan today</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="exportBtn" style="margin-top:10px">Export data (JSON)</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="importBtn" style="margin-top:10px">Import data</ion-button>
            <ion-button expand="block" color="danger" id="wipeBtn" style="margin-top:10px">Wipe all</ion-button>
          </div>
        </ion-content>
      </ion-modal>

      <ion-modal id="planModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Full plan</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closePlan" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <ion-list inset="true" id="planList"></ion-list>
          <div class="muted" style="padding: 0 16px 18px; font-size:12px" id="planModalHint">Full 100-day single-set growth spine with fixed intensity profile.</div>
        </ion-content>
      </ion-modal>

      <!-- TRAINING MODAL (tap to count + auto-rest between sets) -->
      <ion-modal id="trainingModal" backdrop-dismiss="false">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Training</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeTraining" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <div class="trainingWrap">
            <div class="trainingTop">
              <div class="trainingTopRow">
                <div>
                  <div class="muted" style="font-size:12px">Set</div>
                  <div style="font-weight:900; font-size:18px">#<span id="curSet">1</span> / 5</div>
                </div>
                <div>
                  <div class="muted" style="font-size:12px; text-align:right">Target</div>
                  <div style="font-weight:900; font-size:18px; text-align:right"><span id="curTarget">—</span> reps</div>
                </div>
              </div>

              <div class="trainingStrip" id="targetStrip"></div>
            </div>

            <div class="tapArea" id="tapArea" aria-label="Tap to count reps" role="button">
              <div class="tapInner">
                <div class="tapCount" id="curCount">0</div>
                <div class="tapHint" id="tapHint">TAP TO COUNT</div>
                <div class="tapMeta mono muted" id="tapMeta">Tap to count reps. During rest, the timer shows here—tap to skip.</div>
              </div>
            </div>

            <div class="trainingBottom">
              <div class="bottomRow">
                <ion-button class="smallBtn" fill="outline" color="primary" id="finishSetBtn">
                  Swipe right to finish set.
                </ion-button>
              </div>
              <div class="muted" style="font-size:12px; margin-top:10px">
                Auto-rest starts when you hit the target. Swipe right on Finish to advance manually. When all 5 sets are done, we’ll fill the Workout screen for you.
              </div>
            </div>
          </div>
        </ion-content>
      </ion-modal>

      <!-- RECORD MODAL -->
      <ion-modal id="recordModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Session / Record</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeRecord" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content scroll-y="true" style="--overflow:auto">
          <ion-card class="cardDark" style="margin:16px">
            <ion-card-header>
              <ion-card-title>Records</ion-card-title>
              <ion-card-subtitle class="muted">Session total and single-set max</ion-card-subtitle>
            </ion-card-header>
            <ion-card-content>
              <div class="center" style="margin-bottom:16px">
                <div class="bigNumber" id="prNumber">—</div>
                <div class="muted" style="font-weight:700; letter-spacing:.06em;">BEST SESSION TOTAL</div>
                <div class="muted" style="margin-top:8px; font-size:12px">Goal <ion-badge color="primary" id="prGoalBadge" style="margin-left:6px">100</ion-badge></div>
              </div>

              <div class="center" style="padding:12px; border:1px solid rgba(34,48,71,.8); border-radius:12px; background: rgba(18,24,38,.6);">
                <div class="bigNumber" id="maxBest">—</div>
                <div class="muted" style="font-weight:700; letter-spacing:.06em;">BEST SINGLE SET</div>
                <ion-button expand="block" color="primary" id="startMaxBtn" style="margin-top:12px">Start max test</ion-button>
              </div>
            </ion-card-content>
          </ion-card>
        </ion-content>
      </ion-modal>

      <ion-modal id="maxModal" backdrop-dismiss="false">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Max push-up test</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeMax" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content scroll-y="true" style="--overflow:auto">
          <div class="trainingWrap">
            <div class="tapArea" id="maxTapArea" aria-label="Tap to count reps" role="button">
              <div class="tapInner">
                <div class="tapCount" id="maxCount">0</div>
                <div class="tapHint">TAP TO COUNT</div>
                <div class="tapMeta mono muted">One unbroken set. Tap Finish to save.</div>
              </div>
            </div>

            <div class="trainingBottom">
              <div class="bottomRow">
                <ion-button class="smallBtn" fill="outline" color="primary" id="minusMaxBtn">
                  <ion-icon slot="start" name="remove-outline"></ion-icon>
                  −1
                </ion-button>
                <ion-button class="smallBtn" color="primary" id="plusMaxBtn">
                  <ion-icon slot="start" name="add-outline"></ion-icon>
                  +1
                </ion-button>
                <ion-button class="smallBtn" fill="outline" color="primary" id="finishMaxBtn" style="margin-left:auto">
                  Save / finish
                </ion-button>
              </div>
              <div class="muted" style="font-size:12px; margin-top:10px">Goal is your best single-set max.</div>
            </div>
          </div>
        </ion-content>
      </ion-modal>

      <div id="testLog"></div>
    </ion-content>
  </ion-app>

  <!-- Ionicons -->
  <script type="module" src="https://unpkg.com/ionicons@7.2.2/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.2.2/dist/ionicons/ionicons.js"></script>

  <script>
    const KEY_SETTINGS = "pu100_settings_v4";
    const KEY_START_DATE = "pu100_start_date_v4";
    const KEY_WORKOUTS = "pu100_workouts_v4";
    const KEY_MAX_SINGLE = "pu100_max_single_v1";
    const KEY_PROGRESS_DAY = "pu100_progress_day_v1";
    let audioCtx = null;

    const $ = (id) => document.getElementById(id);

    function isoToday() {
      const d = new Date();
      const tzOff = d.getTimezoneOffset() * 60000;
      return new Date(d.getTime() - tzOff).toISOString().slice(0, 10);
    }

    let currentDate = isoToday();

    function clampInt(x, min, max) {
      return Math.max(min, Math.min(max, Math.trunc(x)));
    }

    function roundReps(x, mode) {
      if (mode === "up") return Math.ceil(x);
      if (mode === "nearest") return Math.round(x);
      return Math.floor(x);
    }

    function parseCSVNums(str) {
      return String(str)
        .split(",")
        .map(s => s.trim())
        .filter(Boolean)
        .map(n => Number(n))
        .filter(n => Number.isFinite(n));
    }

    function toast(message) {
      const t = document.createElement('ion-toast');
      t.message = message;
      t.duration = 1400;
      t.position = 'bottom';
      document.body.appendChild(t);
      return t.present().then(() => t.addEventListener('didDismiss', () => t.remove()));
    }

    async function ensureDefined(tagName) {
      if (!tagName) return;
      await customElements.whenDefined(tagName.toLowerCase());
    }

    async function ready(el) {
      if (!el) return;
      if (typeof el.componentOnReady === 'function') {
        try { await el.componentOnReady(); } catch {}
      }
    }

    async function presentOverlay(el) {
      if (!el) return;
      await ensureDefined(el.tagName);
      await ready(el);
      if (typeof el.present === 'function') return el.present();
    }

    async function dismissOverlay(el) {
      if (!el) return;
      await ensureDefined(el.tagName);
      await ready(el);
      if (typeof el.dismiss === 'function') return el.dismiss();
    }

    function getDayPlan(day, settings) {
      const {
        startMax,
        maxReps,
        goalMax = 100,
        totalDays = 100,
        rounding,
        intensityProfile = [0.85, 0.80, 0.75, 0.70, 0.65]
      } = settings;

      const d = clampInt(day, 1, totalDays);
      const start = Number.isFinite(startMax) ? startMax : maxReps;
      const safeStart = clampInt(start || 30, 1, goalMax || 100);
      const safeGoal = clampInt(goalMax || 100, 1, 100000);

      const t = totalDays === 1 ? 1 : (d - 1) / (totalDays - 1);
      const targetMaxRaw = safeStart + t * (safeGoal - safeStart);
      const targetMax = clampInt(roundReps(targetMaxRaw, rounding || 'nearest'), 1, safeGoal);

      const intensities = Array.isArray(intensityProfile) && intensityProfile.length === 5
        ? intensityProfile
        : [0.85, 0.80, 0.75, 0.70, 0.65];

      const sets = intensities.map((pct) => {
        const val = pct * targetMax;
        return clampInt(roundReps(val, rounding || 'nearest'), 1, safeGoal);
      });

      // enforce non-increasing order if rounding caused bumps
      for (let i = 1; i < sets.length; i += 1) {
        if (sets[i] > sets[i - 1]) sets[i] = sets[i - 1];
      }

      const total = sets.reduce((a, b) => a + b, 0);

      return {
        day: d,
        targetMax,
        sets,
        total,
        targetTotal: total,
        restModel: {
          base: settings.baseRestSeconds,
          min: settings.minRestSeconds,
          max: settings.maxRestSeconds
        }
      };
    }

    // Backwards-friendly alias
    const generateTargetForDay = getDayPlan;

    function getRestSeconds(setIndex, targetReps, actualReps, settings) {
      const {
        baseRestSeconds,
        minRestSeconds,
        maxRestSeconds
      } = settings;

      const delta = actualReps - targetReps;
      let perfMultiplier = 1;
      if (delta >= 3) perfMultiplier = 0.80;
      else if (delta >= -2) perfMultiplier = 1.00;
      else if (delta >= -4) perfMultiplier = 1.20;
      else perfMultiplier = 1.40;

      const posMultipliers = [0.90, 1.00, 1.05, 1.10, 1.15];
      const posMultiplier = posMultipliers[clampInt(setIndex, 0, 4)] ?? 1;

      const raw = (baseRestSeconds || 0) * perfMultiplier * posMultiplier;
      const clamped = clampInt(Math.round(raw), minRestSeconds, maxRestSeconds);
      return clamped;
    }

    function loadSettings() {
      const defaults = {
        startMax: 30,
        goalMax: 100,
        totalDays: 100,
        rounding: "nearest",
        intensityProfile: [0.85, 0.80, 0.75, 0.70, 0.65],
        baseRestSeconds: 90,
        minRestSeconds: 45,
        maxRestSeconds: 240,
        soundOn: true
      };
      const saved = localStorage.getItem(KEY_SETTINGS);
      if (!saved) return defaults;
      try {
        const obj = JSON.parse(saved);
        const baseRestSeconds = Number.isFinite(obj.baseRestSeconds) ? obj.baseRestSeconds
          : Number.isFinite(obj.restSeconds) ? obj.restSeconds
          : defaults.baseRestSeconds;
        return {
          ...defaults,
          ...obj,
          startMax: Number.isFinite(obj.startMax) ? obj.startMax : Number.isFinite(obj.maxReps) ? obj.maxReps : defaults.startMax,
          goalMax: Number.isFinite(obj.goalMax) ? obj.goalMax : defaults.goalMax,
          intensityProfile: Array.isArray(obj.intensityProfile) && obj.intensityProfile.length === 5 ? obj.intensityProfile : defaults.intensityProfile,
          baseRestSeconds,
          restSeconds: baseRestSeconds,
          minRestSeconds: Number.isFinite(obj.minRestSeconds) ? obj.minRestSeconds : defaults.minRestSeconds,
          maxRestSeconds: Number.isFinite(obj.maxRestSeconds) ? obj.maxRestSeconds : defaults.maxRestSeconds,
          soundOn: obj.soundOn !== false
        };
      } catch {
        return defaults;
      }
    }

    function saveSettings(s) {
      localStorage.setItem(KEY_SETTINGS, JSON.stringify(s));
    }

    function loadStartDate() {
      return localStorage.getItem(KEY_START_DATE) || null;
    }

    function setStartDate(iso) {
      localStorage.setItem(KEY_START_DATE, iso);
    }

    function loadProgressDay(totalDays = 100) {
      const raw = Number(localStorage.getItem(KEY_PROGRESS_DAY));
      const n = Number.isFinite(raw) ? raw : 1;
      return clampInt(n, 1, totalDays);
    }

    function setProgressDay(day, totalDays = 100) {
      const n = clampInt(day, 1, totalDays);
      localStorage.setItem(KEY_PROGRESS_DAY, String(n));
      return n;
    }

    function loadMaxSingle() {
      const raw = localStorage.getItem(KEY_MAX_SINGLE);
      if (!raw) return 0;
      const n = Number(raw);
      return Number.isFinite(n) && n > 0 ? n : 0;
    }

    function saveMaxSingle(n) {
      localStorage.setItem(KEY_MAX_SINGLE, String(Math.max(0, Math.trunc(n))));
    }

    function loadWorkouts() {
      const saved = localStorage.getItem(KEY_WORKOUTS);
      if (!saved) return [];
      try {
        const arr = JSON.parse(saved);
        return Array.isArray(arr) ? arr : [];
      } catch {
        return [];
      }
    }

    function saveWorkouts(arr) {
      localStorage.setItem(KEY_WORKOUTS, JSON.stringify(arr));
    }

    function computePlanDay(isoDate, startIso, totalDays = 100) {
      if (!startIso) return 1;
      const a = new Date(startIso + "T00:00:00");
      const b = new Date(isoDate + "T00:00:00");
      const diffDays = Math.floor((b - a) / 86400000);
      return clampInt(diffDays + 1, 1, clampInt(totalDays, 1, 365));
    }

    function upsertWorkout(workouts, w) {
      const idx = workouts.findIndex(x => x.date === w.date);
      if (idx >= 0) workouts[idx] = w; else workouts.push(w);
      workouts.sort((a, b) => (a.date < b.date ? 1 : -1));
      return workouts;
    }

    function statusForWorkout(workout, target) {
      const total = workout.total;
      const meetsGoal = workout.sets.length === target.sets.length && workout.sets.every((r, i) => r >= (target.sets[i] || 0));
      const meetsTarget = total >= target.total;
      if (meetsGoal) return { label: "Goal hit", color: "success" };
      if (meetsTarget) return { label: "On track", color: "success" };
      if (total >= Math.floor(target.total * 0.85)) return { label: "Close", color: "warning" };
      return { label: "Below", color: "danger" };
    }

    function renderWorkoutView() {
      const settings = loadSettings();
      const workouts = loadWorkouts();
      const dateForView = currentDate || isoToday();

      const planDay = loadProgressDay(settings.totalDays);
      $("planDay").textContent = String(planDay);

      const planBadge = $("planBadge");
      if (planBadge) planBadge.textContent = `Goal ${settings.goalMax || 100}`;

      const planSub = $("planSubText");
      if (planSub) planSub.textContent = `Sessions remaining to day ${settings.totalDays}`;

      const target = generateTargetForDay(planDay, settings);
      $("targetLine").textContent = target.sets.join(" / ") + `  (${target.total} total)`;

      const totalDays = clampInt(Number(settings.totalDays || 100), 1, 365);
      const sessionsLeft = Math.max(0, totalDays - planDay + 1);
      $("sessionsLeft").textContent = String(sessionsLeft);

      const fullPlan = [];
      for (let d = 1; d <= totalDays; d += 1) {
        fullPlan.push(generateTargetForDay(d, settings));
      }

      const remaining = [];
      if (sessionsLeft > 0) {
        for (let d = planDay; d <= totalDays; d += 1) {
          remaining.push(generateTargetForDay(d, settings));
        }
      }

      const previewEl = $("planPreview");
      if (sessionsLeft === 0) {
        previewEl.textContent = "Plan complete";
      } else {
        const preview = remaining.slice(0, 3).map(r => `Day ${r.day}: ${r.sets.join(" / ")}`);
        if (preview.length) {
          previewEl.innerHTML = preview.map(line => line).join("<br>");
        } else {
          previewEl.textContent = "Plan not available";
        }
      }

      renderWorkoutView._planData = { sessionsLeft, remaining, fullPlan, planDay };

      const goalMax = clampInt(Number(settings.goalMax || 100), 1, 100000);
      const pct = Math.max(0, Math.min(100, Math.round((target.targetMax / goalMax) * 100)));
      $("volBar").value = pct / 100;
      $("volPct").textContent = pct + "%";
      $("volGoal").textContent = String(goalMax);

      const toGo = Math.max(0, goalMax - target.targetMax);
      $("toGo").textContent = String(toGo);

      const existing = workouts.find(w => w.date === dateForView);
      if (existing) {
        $("setsDisplay").textContent = existing.sets.join(" / ");
        $("todayTotal").textContent = String(existing.total);
        $("doneChip").innerHTML = '<ion-label>Done: Yes</ion-label>';
        $("doneChip").className = 'chipOk ion-color ion-color-success';
      } else {
        $("setsDisplay").textContent = "—";
        $("todayTotal").textContent = "—";
        $("doneChip").innerHTML = '<ion-label>Done: No</ion-label>';
        $("doneChip").className = 'chipWarn';
      }

      const best = workouts.reduce((m, w) => Math.max(m, w.total || 0), 0);
      $("bestTotal").textContent = best ? String(best) : "—";
      $("prNumber").textContent = best ? String(best) : "—";

      renderWorkoutView._target = target;
    }

    function renderHistoryView() {
      const settings = loadSettings();
      const workouts = loadWorkouts();
      const list = $("historyList");
      list.innerHTML = "";

      if (!workouts.length) {
        const item = document.createElement('ion-item');
        item.innerHTML = '<ion-label class="muted">No workouts saved yet.</ion-label>';
        list.appendChild(item);
        return;
      }

      workouts.slice(0, 60).forEach(w => {
        const target = generateTargetForDay(w.day, settings);
        const st = statusForWorkout(w, target);

        const item = document.createElement('ion-item');
        item.button = true;
        item.detail = true;
        item.addEventListener('click', () => {
          currentDate = w.date;
          $("tabSeg").value = 'workout';
          switchTab('workout');
          renderWorkoutView();
          toast('Loaded workout');
        });

        item.innerHTML = `
          <ion-label>
            <div class="mono" style="font-weight:800">${w.date}  •  Day ${w.day}</div>
            <div class="muted mono">${w.sets.join(' / ')}  (${w.total})</div>
          </ion-label>
          <ion-badge color="${st.color}" slot="end">${st.label}</ion-badge>
        `;

        const sliding = document.createElement('ion-item-sliding');
        const options = document.createElement('ion-item-options');
        options.side = 'end';
        const opt = document.createElement('ion-item-option');
        opt.color = 'danger';
        opt.textContent = 'Delete';
        opt.addEventListener('click', () => {
          const next = loadWorkouts().filter(x => x.date !== w.date);
          saveWorkouts(next);
          toast('Deleted');
          renderHistoryView();
        });
        options.appendChild(opt);
        sliding.appendChild(item);
        sliding.appendChild(options);
        list.appendChild(sliding);
      });
    }

    function renderPlanList() {
      const list = $("planList");
      if (!list) return;
      list.innerHTML = "";

      const planData = renderWorkoutView._planData || { sessionsLeft: 0, remaining: [], fullPlan: [], planDay: 1 };
      const settings = loadSettings();
      const hint = $("planModalHint");
      if (hint) hint.textContent = `Full plan (days 1–${settings.totalDays}). Current day is highlighted.`;
      if (!planData.fullPlan.length) {
        const item = document.createElement('ion-item');
        item.innerHTML = '<ion-label class="muted">No plan available.</ion-label>';
        list.appendChild(item);
        return;
      }

      planData.fullPlan.forEach((entry) => {
        const isCurrent = entry.day === planData.planDay;
        const item = document.createElement('ion-item');
        if (isCurrent) item.classList.add('planCurrent');
        item.innerHTML = `
          <ion-label>
            <div class="mono" style="font-weight:800">Day ${entry.day}${isCurrent ? ' • Current' : ''}</div>
            <div class="muted mono">${entry.sets.join(' / ')}  (${entry.total} total)</div>
          </ion-label>
        `;
        list.appendChild(item);
      });
    }

    function switchTab(tab) {
      const w = $("viewWorkout");
      const h = $("viewHistory");
      if (tab === 'history') {
        w.style.display = 'none';
        h.style.display = '';
        renderHistoryView();
      } else {
        h.style.display = 'none';
        w.style.display = '';
        renderWorkoutView();
      }
    }

    // -----------------------------
    // Training session state
    // -----------------------------
    const session = {
      active: false,
      date: null,
      day: 1,
      targets: [0,0,0,0,0],
      actual: [0,0,0,0,0],
      curIndex: 0,
      resting: false,
      restRemaining: 0,
      restTimer: null
    };

    const maxSession = {
      active: false,
      count: 0
    };

    function stopRestTimer() {
      if (session.restTimer) {
        clearInterval(session.restTimer);
        session.restTimer = null;
      }
    }

    function setRestUI() {
      const hint = $("tapHint");
      const meta = $("tapMeta");
      const count = $("curCount");
      if (!session.resting) {
        return;
      }
      if (count) count.textContent = String(session.restRemaining);
      if (hint) hint.textContent = 'REST';
      if (meta) meta.textContent = 'Tap to skip rest';
    }

    function haptics(ms=40) {
      try { navigator.vibrate?.(ms); } catch {}
    }

    function attachSwipeRight(el, onSwipe) {
      if (!el || typeof onSwipe !== 'function') return;
      let startX = 0;
      let startY = 0;
      let swiping = false;
      const threshold = 70;
      const restraint = 60;

      el.addEventListener('pointerdown', (e) => {
        startX = e.clientX;
        startY = e.clientY;
        swiping = true;
      });

      el.addEventListener('pointermove', (e) => {
        if (!swiping) return;
        const dx = e.clientX - startX;
        const dy = Math.abs(e.clientY - startY);
        if (dx > threshold && dy < restraint) {
          swiping = false;
          onSwipe();
        }
      });

      const stop = () => { swiping = false; };
      el.addEventListener('pointerup', stop);
      el.addEventListener('pointercancel', stop);
      el.addEventListener('pointerleave', stop);
      el.addEventListener('click', (e) => e.preventDefault());
    }

    function getAudioCtx() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        return audioCtx;
      } catch {
        return null;
      }
    }

    function playBeep() {
      const s = loadSettings();
      if (s.soundOn === false) return;
      const ctx = getAudioCtx();
      if (!ctx) return;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(880, now);
      gain.gain.setValueAtTime(0.09, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
      osc.connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.12);
    }

    function renderSessionUI() {
      const i = session.curIndex;
      $("curSet").textContent = String(i + 1);
      $("curTarget").textContent = String(session.targets[i]);
      if (session.resting) {
        $("curCount").textContent = String(session.restRemaining);
        $("tapHint").textContent = 'REST';
        $("tapMeta").textContent = 'Tap to skip rest';
      } else {
        $("curCount").textContent = String(session.actual[i]);
        $("tapHint").textContent = 'TAP TO COUNT';
        $("tapMeta").textContent = 'Tap to count reps. During rest, the timer shows here—tap to skip.';
      }

      // strip
      const strip = $("targetStrip");
      strip.innerHTML = '';
      session.targets.forEach((t, idx) => {
        const pill = document.createElement('div');
        pill.className = 'setPill';
        pill.textContent = t;
        if (idx === i) pill.classList.add('active');
        if (session.actual[idx] > 0 && (idx < i || (idx === i && session.actual[idx] >= t))) pill.classList.add('done');
        strip.appendChild(pill);
      });

      setRestUI();

      // Disable tap while resting
      $("tapArea").style.opacity = session.resting ? '0.8' : '1';
    }

    function restSecondsForSet(setIndex) {
      const settings = loadSettings();
      const targetReps = session.targets[setIndex] || 0;
      const actualReps = session.actual[setIndex] || 0;
      return getRestSeconds(setIndex, targetReps, actualReps, settings);
    }

    function startRest(seconds) {
      stopRestTimer();
      const s = loadSettings();
      const base = Number.isFinite(seconds) ? seconds : s.baseRestSeconds || 90;
      session.resting = true;
      session.restRemaining = clampInt(Number(base || s.baseRestSeconds || 90), s.minRestSeconds, s.maxRestSeconds);
      renderSessionUI();
      haptics(60);

      session.restTimer = setInterval(() => {
        session.restRemaining -= 1;
        if (session.restRemaining <= 0) {
          stopRestTimer();
          session.resting = false;
          session.restRemaining = 0;
          renderSessionUI();
          toast('Go!');
          haptics(120);
          return;
        }
        setRestUI();
      }, 1000);
    }

    function skipRest() {
      stopRestTimer();
      session.resting = false;
      session.restRemaining = 0;
      renderSessionUI();
      toast('Rest skipped');
    }

    function maybeAutoAdvance() {
      const i = session.curIndex;
      const target = session.targets[i];
      const done = session.actual[i] >= target;
      if (!done) return;

      // If last set, finish session
      if (i >= 4) {
        finishSession();
        return;
      }

      const restSeconds = restSecondsForSet(i);

      // Advance to next set and start rest
      session.curIndex += 1;
      renderSessionUI();
      startRest(restSeconds);
    }

    function incRep(delta) {
      if (!session.active) return;
      if (session.resting) return;
      const i = session.curIndex;
      const prev = session.actual[i];
      session.actual[i] = clampInt(session.actual[i] + delta, 0, 999);
      if (session.actual[i] > prev && delta > 0) playBeep();
      $("curCount").textContent = String(session.actual[i]);
      haptics(20);
      // lightweight render: only fully render when reaching target or correcting below
      if (session.actual[i] === session.targets[i]) {
        toast('Target hit');
        renderSessionUI();
        maybeAutoAdvance();
      } else {
        // Update strip done state occasionally
        if (session.actual[i] > session.targets[i] || session.actual[i] === 0) renderSessionUI();
      }
    }

    function finishSetManual() {
      if (!session.active) return;
      if (session.resting) return;
      const completedIndex = session.curIndex;
      // Treat current count as final and advance
      if (session.curIndex >= 4) {
        finishSession();
        return;
      }
      const restSeconds = restSecondsForSet(completedIndex);
      session.curIndex += 1;
      renderSessionUI();
      startRest(restSeconds);
    }

    function startSession() {
      const settings = loadSettings();
      const date = currentDate || isoToday();
      currentDate = date;

      session.active = true;
      session.date = date;
      session.day = loadProgressDay(settings.totalDays);

      const target = generateTargetForDay(session.day, settings);
      session.targets = [...target.sets];
      session.actual = [0,0,0,0,0];
      session.curIndex = 0;
      session.resting = false;
      session.restRemaining = 0;
      stopRestTimer();

      renderSessionUI();
    }

    function finishSession() {
      stopRestTimer();
      session.resting = false;

      const date = session.date || currentDate || isoToday();
      const settings = loadSettings();
      const day = loadProgressDay(settings.totalDays);
      const sets = [...session.actual];
      const total = sets.reduce((a, b) => a + b, 0);

      const targetPlan = generateTargetForDay(day, settings);
      const success = sets.length === targetPlan.sets.length && sets.every((rep, idx) => rep >= (targetPlan.sets[idx] || 0));

      // Persist workout automatically
      const w = { date, day, sets, total };
      const workouts = upsertWorkout(loadWorkouts(), w);
      saveWorkouts(workouts);

      // Advance progression only if all targets met
      if (success) {
        setProgressDay(Math.min(day + 1, settings.totalDays), settings.totalDays);
      }

      // Update UI
      currentDate = date;
      renderWorkoutView();
      renderHistoryView();

      // Reflect completion badges immediately
      $("setsDisplay").textContent = sets.join(" / ");
      $("todayTotal").textContent = String(total);
      $("doneChip").innerHTML = '<ion-label>Done: Yes</ion-label>';
      $("doneChip").className = 'chipOk ion-color ion-color-success';

      session.active = false;

      toast('Session saved');
      dismissOverlay(window._trainingModal);
      haptics(120);
    }

    // -----------------------------
    // Max single-set test
    // -----------------------------
    function renderMaxUI() {
      $("maxCount").textContent = String(maxSession.count);
    }

    function incMax(delta) {
      if (!maxSession.active) return;
      maxSession.count = clampInt(maxSession.count + delta, 0, 9999);
      renderMaxUI();
      haptics(20);
    }

    function startMaxTest() {
      maxSession.active = true;
      maxSession.count = 0;
      renderMaxUI();
    }

    function finishMaxTest() {
      if (!maxSession.active) return;
      maxSession.active = false;
      const best = loadMaxSingle();
      const next = Math.max(best, maxSession.count);
      saveMaxSingle(next);
      $("maxBest").textContent = String(next || "—");
      toast(next > best ? 'New max saved' : 'Saved');
      dismissOverlay(window._maxModal);
    }

    // -----------------------------
    // Self-tests
    // -----------------------------
    function runSelfTests() {
      const settings = loadSettings();

      const s1 = { ...settings, startMax: 30, goalMax: 100, rounding: 'nearest' };
      const t1 = generateTargetForDay(1, s1);
      if (t1.sets.length !== 5 || t1.sets[0] < t1.sets[1]) {
        console.warn('Self-test failed: monotonic sets', t1.sets);
      }

      // Session advance test
      const tmp = {
        active: true,
        targets: [2,2,2,2,2],
        actual: [0,0,0,0,0],
        curIndex: 0,
        resting: false
      };
      if (tmp.targets.length !== 5) console.warn('Self-test failed: targets length');
    }

    // -----------------------------
    // Wire up events
    // -----------------------------
    window.addEventListener('load', async () => {
      await ensureDefined('ion-modal');
      await ensureDefined('ion-toast');
      await ensureDefined('ion-alert');

      const settingsModal = $("settingsModal");
      const trainingModal = $("trainingModal");
      const recordModal = $("recordModal");
      const planModal = $("planModal");
      const maxModal = $("maxModal");
      window._trainingModal = trainingModal;
      window._maxModal = maxModal;

      await Promise.all([ready(settingsModal), ready(trainingModal), ready(recordModal), ready(planModal), ready(maxModal)]);

      // Always track today's date at startup
      currentDate = isoToday();

      const s = loadSettings();
      $("maxReps").value = s.startMax ?? s.maxReps;
      $("startPercent").value = '—';
      $("startPercent").disabled = true;
      $("drops").value = '85,80,75,70,65';
      $("drops").disabled = true;
      $("rest").value = s.baseRestSeconds;
      $("beepToggle").checked = s.soundOn !== false;
      $("planDays").value = s.totalDays;
      $("goalVolume").value = s.goalMax;
      $("rounding").value = s.rounding;

      runSelfTests();
      renderWorkoutView();
      renderHistoryView();

      $("tabSeg").addEventListener('ionChange', (e) => switchTab(e.detail.value));

      $("settingsBtn").addEventListener('click', () => presentOverlay(settingsModal));
      $("closeSettings").addEventListener('click', () => dismissOverlay(settingsModal));

      // Start training: opens full session UI
      $("startTrainingBtn").addEventListener('click', async () => {
        if (!currentDate) currentDate = isoToday();
        startSession();
        await presentOverlay(trainingModal);
      });

      // Close training
      $("closeTraining").addEventListener('click', async () => {
        // Do not lose counts accidentally
        const alert = document.createElement('ion-alert');
        alert.header = 'End session?';
        alert.message = 'Your current session progress will be kept (not saved) unless you finish it.';
        alert.buttons = [
          { text: 'Cancel', role: 'cancel' },
          {
            text: 'End',
            role: 'destructive',
            handler: () => {
              stopRestTimer();
              session.active = false;
              session.resting = false;
              session.restRemaining = 0;
              dismissOverlay(trainingModal);
            }
          }
        ];
        document.body.appendChild(alert);
        await presentOverlay(alert);
        alert.addEventListener('didDismiss', () => alert.remove());
      });

      // Tap / click to count
      const tapArea = $("tapArea");
      const tapHandler = (e) => {
        e.preventDefault();
        if (session.resting) {
          skipRest();
          return;
        }
        incRep(1);
        // Auto-advance if above target too
        maybeAutoAdvance();
      };
      // pointerdown for immediacy; avoid double-fire by skipping click
      tapArea.addEventListener('pointerdown', tapHandler);

      attachSwipeRight($("finishSetBtn"), () => {
        finishSetManual();
        haptics(50);
      });

      // Record modal
      $("sessionBtn").addEventListener('click', async () => {
        const best = loadWorkouts().reduce((m, w) => Math.max(m, w.total || 0), 0);
        $("prNumber").textContent = best ? String(best) : "—";
        const sPlan = loadSettings();
        $("prGoalBadge").textContent = String(sPlan.goalMax || 100);
        $("maxBest").textContent = String(loadMaxSingle() || "—");
        await presentOverlay(recordModal);
      });
      $("closeRecord").addEventListener('click', () => dismissOverlay(recordModal));

      $("startMaxBtn").addEventListener('click', async () => {
        startMaxTest();
        await presentOverlay(maxModal);
      });
      $("closeMax").addEventListener('click', () => dismissOverlay(maxModal));
      $("plusMaxBtn").addEventListener('click', () => incMax(1));
      $("minusMaxBtn").addEventListener('click', () => incMax(-1));
      $("finishMaxBtn").addEventListener('click', () => finishMaxTest());
      $("maxTapArea").addEventListener('pointerdown', (e) => { e.preventDefault(); incMax(1); });
      $("maxTapArea").addEventListener('click', (e) => { e.preventDefault(); incMax(1); });

      $("viewPlanBtn").addEventListener('click', async () => {
        renderPlanList();
        await presentOverlay(planModal);
      });
      $("closePlan").addEventListener('click', () => dismissOverlay(planModal));

      // Save settings
      $("saveSettingsBtn").addEventListener('click', () => {
        const startMax = Number($("maxReps").value);
        const baseRestSeconds = Number($("rest").value);
        const totalDays = Number($("planDays").value);
        const goalMax = Number($("goalVolume").value);
        const rounding = $("rounding").value;
        const soundOn = Boolean($("beepToggle").checked);

        if (!Number.isFinite(startMax) || startMax < 1) return toast('maxReps must be >= 1');
        if (!Number.isFinite(baseRestSeconds) || baseRestSeconds < 10) return toast('Rest seconds must be >= 10');
        if (!Number.isFinite(totalDays) || totalDays < 1 || totalDays > 365) return toast('Plan days must be 1-365');
        if (!Number.isFinite(goalMax) || goalMax < 1 || goalMax > 100000) return toast('Goal max must be 1-100000');

        const cur = loadSettings();
        saveSettings({
          ...cur,
          startMax,
          maxReps: startMax,
          goalMax,
          intensityProfile: [0.85, 0.80, 0.75, 0.70, 0.65],
          baseRestSeconds,
          restSeconds: baseRestSeconds,
          totalDays,
          goalMax,
          rounding,
          soundOn
        });
        toast('Settings saved');
        renderWorkoutView();
        renderHistoryView();
      });

      // Reset plan
      $("startTodayBtn").addEventListener('click', () => {
        setStartDate(isoToday());
        currentDate = isoToday();
        setProgressDay(1, loadSettings().totalDays);
        toast('Plan reset to today (Day 1)');
        renderWorkoutView();
        renderHistoryView();
      });

      // Export
      $("exportBtn").addEventListener('click', () => {
        const payload = {
          settings: loadSettings(),
          startDate: loadStartDate(),
          workouts: loadWorkouts(),
          maxSingle: loadMaxSingle(),
          exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `pushup100-backup-${isoToday()}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
        toast('Exported JSON');
      });

      // Import
      $("importBtn").addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = async () => {
          const file = input.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            const payload = JSON.parse(text);
            if (payload.settings) saveSettings(payload.settings);
            if (payload.startDate) setStartDate(payload.startDate);
            if (Array.isArray(payload.workouts)) saveWorkouts(payload.workouts);
            if (Number.isFinite(payload.maxSingle)) saveMaxSingle(payload.maxSingle);
            toast('Imported');
            renderWorkoutView();
            renderHistoryView();
          } catch {
            toast('Import failed');
          }
        };
        input.click();
      });

      // Wipe
      $("wipeBtn").addEventListener('click', async () => {
        const alert = document.createElement('ion-alert');
        alert.header = 'Wipe all data?';
        alert.message = 'This deletes workouts and settings from this device.';
        alert.buttons = [
          { text: 'Cancel', role: 'cancel' },
          {
            text: 'Wipe',
            role: 'destructive',
            handler: () => {
              localStorage.removeItem(KEY_SETTINGS);
              localStorage.removeItem(KEY_START_DATE);
              localStorage.removeItem(KEY_WORKOUTS);
              localStorage.removeItem(KEY_MAX_SINGLE);
              localStorage.removeItem(KEY_PROGRESS_DAY);
              toast('Wiped');

              const s2 = loadSettings();
              $("maxReps").value = s2.startMax ?? s2.maxReps;
              $("startPercent").value = '—';
              $("drops").value = '85,80,75,70,65';
              $("rest").value = s2.baseRestSeconds;
              $("beepToggle").checked = s2.soundOn !== false;
              $("planDays").value = s2.totalDays;
              $("goalVolume").value = s2.goalMax;
              $("rounding").value = s2.rounding;
              currentDate = isoToday();
              setProgressDay(1, s2.totalDays);
              $("maxBest").textContent = '—';

              renderWorkoutView();
              renderHistoryView();
            }
          }
        ];
        document.body.appendChild(alert);
        await presentOverlay(alert);
        alert.addEventListener('didDismiss', () => alert.remove());
      });
    });
  </script>
</body>
</html>

