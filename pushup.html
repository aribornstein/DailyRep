<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>100 PushUps</title>
  <meta name="theme-color" content="#0b0f14" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />

  <!-- Ionic (no build step): https://ionicframework.com/docs/intro/cdn -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/dist/ionic/ionic.esm.js"></script>
  <script nomodule src="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/dist/ionic/ionic.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@ionic/core@7.8.6/css/ionic.bundle.css" />

  <style>
    :root {
      --ion-color-primary: #ff9500;
      --ion-color-primary-rgb: 255,149,0;
      --ion-background-color: #0b0f14;
      --ion-text-color: #e7eef7;
    }
    ion-content {
      --background: linear-gradient(180deg, #06080c 0%, #0b0f14 40%, #0b0f14 100%);
    }

    /* Fix iOS alert readability: ion-alert uses scoped CSS (no shadow parts).
       Apply a cssClass to alerts and style the internal elements with higher specificity. */
    ion-alert.dark-alert {
      --backdrop-opacity: 0.65;
      --background: rgba(18, 24, 38, 0.98);
      --min-width: 280px;
      --max-width: 360px;
    }
    .dark-alert .alert-wrapper {
      background: rgba(18, 24, 38, 0.98);
      color: rgba(231, 238, 247, 0.95);
    }
    .dark-alert .alert-head h2,
    .dark-alert .alert-title {
      color: rgba(231, 238, 247, 0.98);
    }
    .dark-alert .alert-message {
      color: rgba(231, 238, 247, 0.88);
    }
    .dark-alert button.alert-button,
    .dark-alert .alert-button {
      color: var(--ion-color-primary);
    }
    .muted { opacity: 0.75; }
    .bigNumber { font-size: 64px; font-weight: 800; line-height: 1; }
    .center { text-align: center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .cardDark {
      --background: rgba(18, 24, 38, 0.9);
      border: 1px solid rgba(34,48,71,.8);
    }
    .chipOk { --background: rgba(124,255,107,.12); }
    .chipWarn { --background: rgba(255,209,102,.12); }
    .chipBad { --background: rgba(255,92,122,.12); }
    .stickyBottom {
      position: sticky;
      bottom: 0;
      z-index: 5;
      background: rgba(11,15,20,.85);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(34,48,71,.6);
      padding: 10px 12px;
    }

    /* Training screen (middle-picture vibe) */
    .trainingWrap {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .trainingTop {
      padding: 14px 16px 8px;
    }
    .trainingTopRow {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
    }
    .trainingStrip {
      padding: 10px 12px;
      margin: 10px 16px 0;
      border: 1px solid rgba(34,48,71,.8);
      border-radius: 14px;
      background: rgba(18,24,38,.75);
      display: flex;
      gap: 10px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .setPill {
      flex: 0 0 auto;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(34,48,71,.9);
      background: #0b1220;
      color: rgba(231,238,247,.9);
      font-weight: 700;
      font-size: 13px;
    }
    .setPill.active {
      border-color: rgba(255,149,0,.9);
      box-shadow: 0 0 0 3px rgba(255,149,0,.18);
      color: white;
    }
    .setPill.done {
      border-color: rgba(124,255,107,.75);
      color: rgba(124,255,107,.95);
    }

    .tapArea {
      flex: 1;
      margin: 14px 16px;
      border-radius: 20px;
      border: 1px solid rgba(34,48,71,.85);
      background: linear-gradient(180deg, rgba(255,149,0,.22), rgba(18,24,38,.65));
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      position: relative;
      overflow: hidden;
    }
    .tapArea:active { transform: scale(0.995); }
    .tapInner { text-align: center; padding: 14px; }
    .tapHint { margin-top: 10px; font-weight: 700; letter-spacing: .06em; opacity: .75; }
    .tapMeta {
      margin-top: 10px;
      font-size: 13px;
      opacity: .78;
    }
    .tapCount {
      font-size: 92px;
      font-weight: 900;
      line-height: 1;
    }

    .trainingBottom {
      padding: 10px 16px 16px;
      border-top: 1px solid rgba(34,48,71,.6);
      background: rgba(11,15,20,.85);
      backdrop-filter: blur(10px);
    }
    .bottomRow {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    #finishSetBtn {
      flex: 1;
      width: 100%;
    }
    /* restBadge removed */
    .smallBtn {
      --border-radius: 14px;
    }

    /* Live swipe progress cue on Finish button */
    .swipeBtn {
      --color: #fff;
      --base-bg: #0b1220;
      --fill-bg: #ff9500;
      --background: rgba(11,18,32,0.95);
      --background-hover: rgba(11,18,32,0.95);
      --border-color: rgba(34,48,71,.9);
      --border-radius: 999px;
      position: relative;
      overflow: hidden;
      isolation: isolate;
      touch-action: pan-y; /* allow vertical scroll, capture horizontal swipe */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      height: 56px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      background: var(--background);
      display: flex;
      align-items: center;
    }

    .swipeBtn .swipeFill {
      position: absolute;
      inset: 0;
      width: 0%;
      background: rgba(255,149,0,0.22);
      pointer-events: none;
      border-radius: 999px;
      transition: width 180ms ease;
    }

    .swipeBtn .swipeKnob {
      position: absolute;
      top: 50%;
      left: 10px;
      width: 44px;
      height: 44px;
      transform: translate(0, -50%);
      border-radius: 999px;
      background: rgba(255,149,0,0.95);
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      z-index: 2;
      pointer-events: auto;
      cursor: grab;
      transition: transform 180ms ease;
      touch-action: none; /* we handle pointer movement */
      display: grid;
      place-items: center;
    }

    .swipeBtn .swipeKnob:active { cursor: grabbing; }

    .swipeBtn .swipeChev {
      width: 10px;
      height: 10px;
      border-right: 2px solid rgba(11,15,20,.75);
      border-top: 2px solid rgba(11,15,20,.75);
      transform: rotate(45deg);
      margin-left: 2px;
      opacity: .95;
      pointer-events: none;
    }

    .swipeBtn .swipeLabel {
      position: relative;
      z-index: 1;
      display: block;
      width: 100%;
      text-align: center;
      font-weight: 800;
      letter-spacing: .02em;
      padding-left: 38px; /* visually balance the knob */
      opacity: .85;
      pointer-events: none;
    }

    /* Hide scrollbars for the strip on iOS */
    .trainingStrip::-webkit-scrollbar { display: none; }

    /* Plan list highlight for current session */
    .planCurrent {
      border-left: 3px solid var(--ion-color-primary);
      background: rgba(255,149,0,.08);
    }

    /* Mini test panel (hidden) */
    #testLog { display:none; }
  </style>
</head>
<body>
  <ion-app>
    <ion-header translucent="true">
      <ion-toolbar color="dark">
        <ion-title>
          <span style="font-weight:800">PushUps</span>
          <span style="color:var(--ion-color-primary); font-weight:800; margin-left:6px">100</span>
        </ion-title>
        <ion-buttons slot="end">
          <ion-button id="settingsBtn" fill="clear">
            <ion-icon name="settings-outline"></ion-icon>
          </ion-button>
        </ion-buttons>
      </ion-toolbar>

      <ion-toolbar color="dark">
        <ion-segment value="workout" id="tabSeg">
          <ion-segment-button value="workout">
            <ion-label>Workout</ion-label>
          </ion-segment-button>
          <ion-segment-button value="history">
            <ion-label>History</ion-label>
          </ion-segment-button>
        </ion-segment>
      </ion-toolbar>
    </ion-header>

    <ion-content fullscreen="true" scroll-y="true" style="--overflow:auto; overscroll-behavior:contain;">
      <!-- WORKOUT VIEW -->
      <div id="viewWorkout">
        <ion-card class="cardDark">
          <ion-card-header>
            <ion-card-title>
              Day <span id="planDay">—</span>
              <span class="muted" style="font-size:14px; font-weight:600; margin-left:8px">Plan: <span id="planBadge">—</span></span>
            </ion-card-title>
            <ion-card-subtitle class="muted">Your daily target (top + back-offs)</ion-card-subtitle>
          </ion-card-header>

          <ion-card-content>
            <div class="center" style="margin: 10px 0 6px;">
              <div class="bigNumber" id="toGo">—</div>
              <div class="muted" style="font-weight:700; letter-spacing:.06em;">PUSH-UPS TO 100 MAX REP</div>
              <div style="margin-top:8px" class="mono muted" id="targetLine">—</div>
            </div>

            <ion-item lines="none" style="--background: transparent; margin-top:10px">
              <ion-label class="muted">Training progress</ion-label>
              <ion-progress-bar id="volBar" value="0" color="primary"></ion-progress-bar>
            </ion-item>
          </ion-card-content>
        </ion-card>

        <ion-card class="cardDark">
          <ion-card-header>
            <ion-card-title>Plan Overview</ion-card-title>
            <ion-card-subtitle class="muted"><span id="planSubText">Sessions remaining to day 100</span></ion-card-subtitle>
          </ion-card-header>
          <ion-card-content>
            <div class="muted">Sessions left: <span id="sessionsLeft">—</span></div>
            <div class="mono muted" id="planPreview" style="margin-top:8px">Plan not available</div>
                <ion-button expand="block" fill="outline" color="primary" id="viewPlanBtn" style="margin-top:12px">View full plan</ion-button>
            </ion-card-content>
            </ion-card>

            <ion-card class="cardDark">
            <ion-card-header>
                <ion-card-title>Today</ion-card-title>
                <ion-card-subtitle class="muted">Session data is auto-saved</ion-card-subtitle>
            </ion-card-header>
            <ion-card-content>
                <div class="muted" style="margin-bottom:8px">Last Completed Sets</div>
                <div class="mono" id="setsDisplay">—</div>
                <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
                <ion-chip id="doneChip" class="chipWarn"><ion-label>Done: —</ion-label></ion-chip>
                <ion-chip class="chipWarn"><ion-label>Total: <span id="todayTotal">—</span></ion-label></ion-chip>
                <ion-chip class="chipWarn"><ion-label>PR total: <span id="bestTotal">—</span></ion-label></ion-chip>
                </div>
            </ion-card-content>
            </ion-card>

            <div class="stickyBottom">
            <div style="display:flex; gap:10px;">
                <ion-button expand="block" color="primary" id="startTrainingBtn" style="flex:1">
                <ion-icon slot="start" name="fitness-outline"></ion-icon>
                Start training
                </ion-button>
                <ion-button expand="block" fill="outline" color="primary" id="sessionBtn" style="flex:1">
                <ion-icon slot="start" name="trophy-outline"></ion-icon>
                Session / record
                </ion-button>
            </div>
        </div>
      </div>

      <!-- HISTORY VIEW -->
      <div id="viewHistory" style="display:none">
        <ion-list inset="true" id="historyList"></ion-list>
        <div style="padding: 0 16px 18px" class="muted">Tip: tap a workout to load it back into the Workout tab.</div>
      </div>

      <!-- SETTINGS MODAL -->
      <ion-modal id="settingsModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Settings</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeSettings" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <ion-list inset="true">
            <ion-item>
              <ion-label position="stacked">Starting Max reps (one set)</ion-label>
              <ion-input id="maxReps" type="number" min="1" value="30"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Top set start % (fixed)</ion-label>
              <ion-input id="startPercent" type="text" value="—" disabled></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Intensity profile (fixed)</ion-label>
              <ion-input id="drops" value="85,80,75,70,65" disabled></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Rest timer (seconds)</ion-label>
              <ion-input id="rest" type="number" min="30" step="5" value="90"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label>Beep on each rep</ion-label>
              <ion-toggle id="beepToggle" checked="true"></ion-toggle>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Plan length (days)</ion-label>
              <ion-input id="planDays" type="number" min="1" max="365" value="100"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Goal max reps (single set)</ion-label>
              <ion-input id="goalVolume" type="number" min="1" max="1000" value="100"></ion-input>
            </ion-item>
            <ion-item>
              <ion-label position="stacked">Rounding</ion-label>
              <ion-select id="rounding" value="nearest">
                <ion-select-option value="down">Down</ion-select-option>
                <ion-select-option value="nearest">Nearest</ion-select-option>
                <ion-select-option value="up">Up</ion-select-option>
              </ion-select>
            </ion-item>
          </ion-list>

          <div style="padding: 0 16px 16px">
            <ion-button expand="block" color="primary" id="saveSettingsBtn">Save settings</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="startTodayBtn" style="margin-top:10px">Start / reset plan today</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="exportBtn" style="margin-top:10px">Export data (JSON)</ion-button>
            <ion-button expand="block" fill="outline" color="primary" id="importBtn" style="margin-top:10px">Import data</ion-button>
            <ion-button expand="block" color="danger" id="wipeBtn" style="margin-top:10px">Wipe all</ion-button>
          </div>
        </ion-content>
      </ion-modal>

      <ion-modal id="planModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Full plan</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closePlan" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <ion-list inset="true" id="planList"></ion-list>
          <div class="muted" style="padding: 0 16px 18px; font-size:12px" id="planModalHint">Full 100-day single-set growth spine with fixed intensity profile.</div>
        </ion-content>
      </ion-modal>

      <!-- TRAINING MODAL (tap to count + auto-rest between sets) -->
      <ion-modal id="trainingModal" backdrop-dismiss="false">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Training</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeTraining" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content>
          <div class="trainingWrap">
            <div class="trainingTop">
              <div class="trainingTopRow">
                <div>
                  <div class="muted" style="font-size:12px">Set</div>
                  <div style="font-weight:900; font-size:18px">#<span id="curSet">1</span> / 5</div>
                </div>
                <div>
                  <div class="muted" style="font-size:12px; text-align:right">Target</div>
                  <div style="font-weight:900; font-size:18px; text-align:right"><span id="curTarget">—</span> reps</div>
                </div>
              </div>

              <div class="trainingStrip" id="targetStrip"></div>
            </div>

            <div class="tapArea" id="tapArea" aria-label="Tap to count reps" role="button">
              <div class="tapInner">
                <div class="tapCount" id="curCount">0</div>
                <div class="tapHint" id="tapHint">TAP TO COUNT</div>
                <div class="tapMeta mono muted" id="tapMeta">Tap to count reps. During rest, the timer shows here—tap to skip.</div>
              </div>
            </div>

            <div class="trainingBottom">
              <div class="bottomRow">
                <div class="swipeBtn" id="finishSetBtn" aria-label="Swipe right to finish set" role="group">
                  <span class="swipeFill" aria-hidden="true"></span>
                  <span class="swipeKnob" role="button" aria-label="Swipe thumb"><span class="swipeChev" aria-hidden="true"></span></span>
                  <span class="swipeLabel">Swipe right to finish set.</span>
                </div>
              </div>
            </div>
          </div>
        </ion-content>
      </ion-modal>

      <!-- RECORD MODAL -->
      <ion-modal id="recordModal">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Session / Record</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeRecord" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content scroll-y="true" style="--overflow:auto">
          <ion-card class="cardDark" style="margin:16px">
            <ion-card-header>
              <ion-card-title>Records</ion-card-title>
              <ion-card-subtitle class="muted">Session total and single-set max</ion-card-subtitle>
            </ion-card-header>
            <ion-card-content>
              <div class="center" style="margin-bottom:16px">
                <div class="bigNumber" id="prNumber">—</div>
                <div class="muted" style="font-weight:700; letter-spacing:.06em;">BEST SESSION TOTAL</div>
                <div class="muted" style="margin-top:8px; font-size:12px">Goal <ion-badge color="primary" id="prGoalBadge" style="margin-left:6px">100</ion-badge></div>
              </div>

              <div class="center" style="padding:12px; border:1px solid rgba(34,48,71,.8); border-radius:12px; background: rgba(18,24,38,.6);">
                <div class="bigNumber" id="maxBest">—</div>
                <div class="muted" style="font-weight:700; letter-spacing:.06em;">BEST SINGLE SET</div>
                <ion-button expand="block" color="primary" id="startMaxBtn" style="margin-top:12px">Start max test</ion-button>
              </div>
            </ion-card-content>
          </ion-card>
        </ion-content>
      </ion-modal>

      <ion-modal id="maxModal" backdrop-dismiss="false">
        <ion-header>
          <ion-toolbar color="dark">
            <ion-title>Max push-up test</ion-title>
            <ion-buttons slot="end">
              <ion-button id="closeMax" fill="clear">Close</ion-button>
            </ion-buttons>
          </ion-toolbar>
        </ion-header>
        <ion-content scroll-y="true" style="--overflow:auto">
          <div class="trainingWrap">
            <div class="tapArea" id="maxTapArea" aria-label="Tap to count reps" role="button">
              <div class="tapInner">
                <div class="tapCount" id="maxCount">0</div>
                <div class="tapHint">TAP TO COUNT</div>
                <div class="tapMeta mono muted">One unbroken set. Tap Finish to save.</div>
              </div>
            </div>

            <div class="trainingBottom">
              <div class="bottomRow">
                <ion-button class="smallBtn" fill="outline" color="primary" id="finishMaxBtn" style="margin-left:auto">
                  Save / finish
                </ion-button>
              </div>
              <div class="muted" style="font-size:12px; margin-top:10px">Goal is your best single-set max.</div>
            </div>
          </div>
        </ion-content>
      </ion-modal>

      <div id="testLog"></div>
    </ion-content>
  </ion-app>

  <!-- Ionicons -->
  <script type="module" src="https://unpkg.com/ionicons@7.2.2/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@7.2.2/dist/ionicons/ionicons.js"></script>

  <script>
    const KEY_SETTINGS = "pu100_settings_v4";
    const KEY_START_DATE = "pu100_start_date_v4";
    const KEY_WORKOUTS = "pu100_workouts_v4";
    const KEY_MAX_SINGLE = "pu100_max_single_v1";
    const KEY_PROGRESS_DAY = "pu100_progress_day_v1";
    const MOTIVATION_LINES = [
      "You showed up. That's the win.",
      "Stronger than yesterday.",
      "Progress beats perfection.",
      "Reps done. Confidence earned.",
      "Discipline just paid interest.",
      "One step closer to 100.",
      "You didn't quit — that matters.",
      "This is how consistency looks.",
      "Your future self approves.",
      "Hard work logged.",
      "Another brick in the wall.",
      "Effort compounds.",
      "You're building something.",
      "Same goal. Stronger body.",
      "Done is powerful.",
      "The strongest oak was once a little nut that held its ground.",
      "Winners never quit and quitters never win."
    ];
    let audioCtx = null;

    // Prefer an actual audio file for beep (more likely to play on iOS even when Silent is on)
    let beepEl = null;
    let beepPrimed = false;
    function getBeepEl() {
      if (!beepEl) {
        beepEl = new Audio('sounds/beep.wav');
        beepEl.preload = 'auto';
        beepEl.volume = 1.0;
        // iOS Safari hint
        beepEl.playsInline = true;
      }
      return beepEl;
    }
    function primeBeep() {
      if (beepPrimed) return;
      // Respect the toggle immediately, even before saving settings
      const toggle = $("beepToggle");
      if (toggle && toggle.checked === false) return;
      const s = loadSettings();
      if (s.soundOn === false) return;
      try {
        const el = getBeepEl();
        // Prime during a user gesture: ensure absolutely silent playback.
        // Some browsers may briefly leak audio if only `volume=0`, so also set `muted=true`.
        const prevMuted = Boolean(el.muted);
        const prevVol = el.volume;
        let restored = false;
        const restore = () => {
          if (restored) return;
          restored = true;
          try { el.pause(); } catch {}
          try { el.currentTime = 0; } catch {}
          el.muted = prevMuted;
          el.volume = prevVol;
        };
        try { el.currentTime = 0; } catch {}
        el.muted = true;
        el.volume = 0;

        const p = el.play();
        // Always restore quickly, even if the play() promise never settles.
        setTimeout(() => {
          beepPrimed = true;
          restore();
        }, 120);

        Promise.resolve(p).then(() => {
          beepPrimed = true;
          restore();
        }).catch(() => {
          // Even if play fails, restore state so we don't leave audio muted.
          restore();
        });
      } catch {}
    }

    // Register service worker for install/offline
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js').catch(() => {});
      });
    }

    const $ = (id) => document.getElementById(id);

    function isoToday() {
      const d = new Date();
      const tzOff = d.getTimezoneOffset() * 60000;
      return new Date(d.getTime() - tzOff).toISOString().slice(0, 10);
    }

    let currentDate = isoToday();

    function clampInt(x, min, max) {
      return Math.max(min, Math.min(max, Math.trunc(x)));
    }

    function roundReps(x, mode) {
      if (mode === "up") return Math.ceil(x);
      if (mode === "nearest") return Math.round(x);
      return Math.floor(x);
    }

    function parseCSVNums(str) {
      return String(str)
        .split(",")
        .map(s => s.trim())
        .filter(Boolean)
        .map(n => Number(n))
        .filter(n => Number.isFinite(n));
    }

    function toast(message) {
      const t = document.createElement('ion-toast');
      t.message = message;
      t.duration = 1400;
      t.position = 'bottom';
      document.body.appendChild(t);
      return t.present().then(() => t.addEventListener('didDismiss', () => t.remove()));
    }

    async function ensureDefined(tagName) {
      if (!tagName) return;
      await customElements.whenDefined(tagName.toLowerCase());
    }

    async function ready(el) {
      if (!el) return;
      if (typeof el.componentOnReady === 'function') {
        try { await el.componentOnReady(); } catch {}
      }
    }

    async function presentOverlay(el) {
      if (!el) return;
      await ensureDefined(el.tagName);
      await ready(el);
      if (typeof el.present === 'function') return el.present();
    }

    async function dismissOverlay(el) {
      if (!el) return;
      await ensureDefined(el.tagName);
      await ready(el);
      if (typeof el.dismiss === 'function') return el.dismiss();
    }

    function getDayPlan(day, settings) {
      const {
        startMax,
        maxReps,
        goalMax = 100,
        totalDays = 100,
        rounding,
        intensityProfile = [0.85, 0.80, 0.75, 0.70, 0.65]
      } = settings;

      const d = clampInt(day, 1, totalDays);
      const start = Number.isFinite(startMax) ? startMax : maxReps;
      const safeStart = clampInt(start || 30, 1, goalMax || 100);
      const safeGoal = clampInt(goalMax || 100, 1, 100000);

      const t = totalDays === 1 ? 1 : (d - 1) / (totalDays - 1);
      const targetMaxRaw = safeStart + t * (safeGoal - safeStart);
      const targetMax = clampInt(roundReps(targetMaxRaw, rounding || 'nearest'), 1, safeGoal);

      const intensities = Array.isArray(intensityProfile) && intensityProfile.length === 5
        ? intensityProfile
        : [0.85, 0.80, 0.75, 0.70, 0.65];

      const sets = intensities.map((pct) => {
        const val = pct * targetMax;
        return clampInt(roundReps(val, rounding || 'nearest'), 1, safeGoal);
      });

      // enforce non-increasing order if rounding caused bumps
      for (let i = 1; i < sets.length; i += 1) {
        if (sets[i] > sets[i - 1]) sets[i] = sets[i - 1];
      }

      const total = sets.reduce((a, b) => a + b, 0);

      return {
        day: d,
        targetMax,
        sets,
        total,
        targetTotal: total,
        restModel: {
          base: settings.baseRestSeconds,
          min: settings.minRestSeconds,
          max: settings.maxRestSeconds
        }
      };
    }

    // Backwards-friendly alias
    const generateTargetForDay = getDayPlan;

    function getRestSeconds(setIndex, targetReps, actualReps, settings) {
      const {
        baseRestSeconds,
        minRestSeconds,
        maxRestSeconds
      } = settings;

      const delta = actualReps - targetReps;
      let perfMultiplier = 1;
      if (delta >= 3) perfMultiplier = 0.80;
      else if (delta >= -2) perfMultiplier = 1.00;
      else if (delta >= -4) perfMultiplier = 1.20;
      else perfMultiplier = 1.40;

      const posMultipliers = [0.90, 1.00, 1.05, 1.10, 1.15];
      const posMultiplier = posMultipliers[clampInt(setIndex, 0, 4)] ?? 1;

      const raw = (baseRestSeconds || 0) * perfMultiplier * posMultiplier;
      const clamped = clampInt(Math.round(raw), minRestSeconds, maxRestSeconds);
      return clamped;
    }

    function loadSettings() {
      const defaults = {
        startMax: 30,
        goalMax: 100,
        totalDays: 100,
        rounding: "nearest",
        intensityProfile: [0.85, 0.80, 0.75, 0.70, 0.65],
        baseRestSeconds: 90,
        minRestSeconds: 45,
        maxRestSeconds: 240,
        soundOn: true
      };
      const saved = localStorage.getItem(KEY_SETTINGS);
      if (!saved) return defaults;
      try {
        const obj = JSON.parse(saved);
        const baseRestSeconds = Number.isFinite(obj.baseRestSeconds) ? obj.baseRestSeconds
          : Number.isFinite(obj.restSeconds) ? obj.restSeconds
          : defaults.baseRestSeconds;
        return {
          ...defaults,
          ...obj,
          startMax: Number.isFinite(obj.startMax) ? obj.startMax : Number.isFinite(obj.maxReps) ? obj.maxReps : defaults.startMax,
          goalMax: Number.isFinite(obj.goalMax) ? obj.goalMax : defaults.goalMax,
          intensityProfile: Array.isArray(obj.intensityProfile) && obj.intensityProfile.length === 5 ? obj.intensityProfile : defaults.intensityProfile,
          baseRestSeconds,
          restSeconds: baseRestSeconds,
          minRestSeconds: Number.isFinite(obj.minRestSeconds) ? obj.minRestSeconds : defaults.minRestSeconds,
          maxRestSeconds: Number.isFinite(obj.maxRestSeconds) ? obj.maxRestSeconds : defaults.maxRestSeconds,
          soundOn: obj.soundOn !== false
        };
      } catch {
        return defaults;
      }
    }

    function saveSettings(s) {
      localStorage.setItem(KEY_SETTINGS, JSON.stringify(s));
    }

    function loadStartDate() {
      return localStorage.getItem(KEY_START_DATE) || null;
    }

    function setStartDate(iso) {
      localStorage.setItem(KEY_START_DATE, iso);
    }

    function loadProgressDay(totalDays = 100) {
      const raw = Number(localStorage.getItem(KEY_PROGRESS_DAY));
      const n = Number.isFinite(raw) ? raw : 1;
      return clampInt(n, 1, totalDays);
    }

    function setProgressDay(day, totalDays = 100) {
      const n = clampInt(day, 1, totalDays);
      localStorage.setItem(KEY_PROGRESS_DAY, String(n));
      return n;
    }

    function loadMaxSingle() {
      const raw = localStorage.getItem(KEY_MAX_SINGLE);
      if (!raw) return 0;
      const n = Number(raw);
      return Number.isFinite(n) && n > 0 ? n : 0;
    }

    function saveMaxSingle(n) {
      localStorage.setItem(KEY_MAX_SINGLE, String(Math.max(0, Math.trunc(n))));
    }

    function loadWorkouts() {
      const saved = localStorage.getItem(KEY_WORKOUTS);
      if (!saved) return [];
      try {
        const arr = JSON.parse(saved);
        return Array.isArray(arr) ? arr : [];
      } catch {
        return [];
      }
    }

    function saveWorkouts(arr) {
      localStorage.setItem(KEY_WORKOUTS, JSON.stringify(arr));
    }

    function computePlanDay(isoDate, startIso, totalDays = 100) {
      if (!startIso) return 1;
      const a = new Date(startIso + "T00:00:00");
      const b = new Date(isoDate + "T00:00:00");
      const diffDays = Math.floor((b - a) / 86400000);
      return clampInt(diffDays + 1, 1, clampInt(totalDays, 1, 365));
    }

    function upsertWorkout(workouts, w) {
      const idx = workouts.findIndex(x => x.date === w.date);
      if (idx >= 0) workouts[idx] = w; else workouts.push(w);
      workouts.sort((a, b) => (a.date < b.date ? 1 : -1));
      return workouts;
    }

    function statusForWorkout(workout, target) {
      const total = workout.total;
      const meetsGoal = workout.sets.length === target.sets.length && workout.sets.every((r, i) => r >= (target.sets[i] || 0));
      const meetsTarget = total >= target.total;
      if (meetsGoal) return { label: "Goal hit", color: "success" };
      if (meetsTarget) return { label: "On track", color: "success" };
      if (total >= Math.floor(target.total * 0.85)) return { label: "Close", color: "warning" };
      return { label: "Below", color: "danger" };
    }

    function renderWorkoutView() {
      const settings = loadSettings();
      const workouts = loadWorkouts();
      const dateForView = currentDate || isoToday();

      const planDay = loadProgressDay(settings.totalDays);
      $("planDay").textContent = String(planDay);

      const planBadge = $("planBadge");
      if (planBadge) planBadge.textContent = `Goal ${settings.goalMax || 100}`;

      const planSub = $("planSubText");
      if (planSub) planSub.textContent = `Sessions remaining to day ${settings.totalDays}`;

      const target = generateTargetForDay(planDay, settings);
      $("targetLine").textContent = target.sets.join(" / ") + `  (${target.total} total)`;

      const totalDays = clampInt(Number(settings.totalDays || 100), 1, 365);
      const sessionsLeft = Math.max(0, totalDays - planDay + 1);
      $("sessionsLeft").textContent = String(sessionsLeft);

      const fullPlan = [];
      for (let d = 1; d <= totalDays; d += 1) {
        fullPlan.push(generateTargetForDay(d, settings));
      }

      const remaining = [];
      if (sessionsLeft > 0) {
        for (let d = planDay; d <= totalDays; d += 1) {
          remaining.push(generateTargetForDay(d, settings));
        }
      }

      const previewEl = $("planPreview");
      if (sessionsLeft === 0) {
        previewEl.textContent = "Plan complete";
      } else {
        const preview = remaining.slice(0, 3).map(r => `Day ${r.day}: ${r.sets.join(" / ")}`);
        if (preview.length) {
          previewEl.innerHTML = preview.map(line => line).join("<br>");
        } else {
          previewEl.textContent = "Plan not available";
        }
      }

      renderWorkoutView._planData = { sessionsLeft, remaining, fullPlan, planDay };

      const goalMax = clampInt(Number(settings.goalMax || 100), 1, 100000);
      const pct = Math.max(0, Math.min(100, Math.round((target.targetMax / goalMax) * 100)));
      $("volBar").value = pct / 100;
      const volPctEl = $("volPct");
      const volGoalEl = $("volGoal");
      if (volPctEl) volPctEl.textContent = pct + "%";
      if (volGoalEl) volGoalEl.textContent = String(goalMax);

      const toGo = Math.max(0, goalMax - target.targetMax);
      $("toGo").textContent = String(toGo);

      const existing = workouts.find(w => w.date === dateForView);
      if (existing) {
        $("setsDisplay").textContent = existing.sets.join(" / ");
        $("todayTotal").textContent = String(existing.total);
        $("doneChip").innerHTML = '<ion-label>Done: Yes</ion-label>';
        $("doneChip").className = 'chipOk ion-color ion-color-success';
      } else {
        $("setsDisplay").textContent = "—";
        $("todayTotal").textContent = "—";
        $("doneChip").innerHTML = '<ion-label>Done: No</ion-label>';
        $("doneChip").className = 'chipWarn';
      }

      const best = workouts.reduce((m, w) => Math.max(m, w.total || 0), 0);
      $("bestTotal").textContent = best ? String(best) : "—";
      $("prNumber").textContent = best ? String(best) : "—";

      renderWorkoutView._target = target;
    }

    function renderHistoryView() {
      const settings = loadSettings();
      const workouts = loadWorkouts();
      const list = $("historyList");
      list.innerHTML = "";

      if (!workouts.length) {
        const item = document.createElement('ion-item');
        item.innerHTML = '<ion-label class="muted">No workouts saved yet.</ion-label>';
        list.appendChild(item);
        return;
      }

      workouts.slice(0, 60).forEach(w => {
        const target = generateTargetForDay(w.day, settings);
        const st = statusForWorkout(w, target);

        const item = document.createElement('ion-item');
        item.button = true;
        item.detail = true;
        item.addEventListener('click', () => {
          currentDate = w.date;
          $("tabSeg").value = 'workout';
          switchTab('workout');
          renderWorkoutView();
          toast('Loaded workout');
        });

        item.innerHTML = `
          <ion-label>
            <div class="mono" style="font-weight:800">${w.date}  •  Day ${w.day}</div>
            <div class="muted mono">${w.sets.join(' / ')}  (${w.total})</div>
          </ion-label>
          <ion-badge color="${st.color}" slot="end">${st.label}</ion-badge>
        `;

        const sliding = document.createElement('ion-item-sliding');
        const options = document.createElement('ion-item-options');
        options.side = 'end';
        const opt = document.createElement('ion-item-option');
        opt.color = 'danger';
        opt.textContent = 'Delete';
        opt.addEventListener('click', () => {
          const next = loadWorkouts().filter(x => x.date !== w.date);
          saveWorkouts(next);
          toast('Deleted');
          renderHistoryView();
        });
        options.appendChild(opt);
        sliding.appendChild(item);
        sliding.appendChild(options);
        list.appendChild(sliding);
      });
    }

    function renderPlanList() {
      const list = $("planList");
      if (!list) return;
      list.innerHTML = "";

      const planData = renderWorkoutView._planData || { sessionsLeft: 0, remaining: [], fullPlan: [], planDay: 1 };
      const settings = loadSettings();
      const hint = $("planModalHint");
      if (hint) hint.textContent = `Full plan (days 1–${settings.totalDays}). Current day is highlighted.`;
      if (!planData.fullPlan.length) {
        const item = document.createElement('ion-item');
        item.innerHTML = '<ion-label class="muted">No plan available.</ion-label>';
        list.appendChild(item);
        return;
      }

      planData.fullPlan.forEach((entry) => {
        const isCurrent = entry.day === planData.planDay;
        const item = document.createElement('ion-item');
        item.lines = 'full';
        item.detail = false;
        item.button = true;
        if (isCurrent) item.classList.add('planCurrent');

        item.addEventListener('click', () => {
          // Avoid changing day mid-session; it can be confusing.
          if (session && session.active) {
            toast('End the current session before changing the day');
            return;
          }

          const nextDay = setProgressDay(entry.day, settings.totalDays);
          currentDate = isoToday();
          renderWorkoutView();
          renderHistoryView();
          renderPlanList();
          toast(`Set plan to Day ${nextDay}`);
        });

        const label = document.createElement('ion-label');
        label.innerHTML = `
          <div class="mono" style="font-weight:800">Day ${entry.day}${isCurrent ? ' • Current' : ''}</div>
          <div class="muted mono">${entry.sets.join(' / ')}</div>
        `;
        item.appendChild(label);

        const badge = document.createElement('ion-badge');
        badge.color = 'primary';
        badge.slot = 'end';
        badge.textContent = String(entry.total);
        item.appendChild(badge);

        list.appendChild(item);
      });
    }

    function switchTab(tab) {
      const w = $("viewWorkout");
      const h = $("viewHistory");
      if (tab === 'history') {
        w.style.display = 'none';
        h.style.display = '';
        renderHistoryView();
      } else {
        h.style.display = 'none';
        w.style.display = '';
        renderWorkoutView();
      }
    }

    // -----------------------------
    // Training session state
    // -----------------------------
    const session = {
      active: false,
      date: null,
      day: 1,
      targets: [0,0,0,0,0],
      actual: [0,0,0,0,0],
      curIndex: 0,
      resting: false,
      restRemaining: 0,
      restTimer: null,
      lastRestSpoken: null,
      speakLocked: false
    };

    const maxSession = {
      active: false,
      count: 0
    };

    function stopRestTimer() {
      if (session.restTimer) {
        clearInterval(session.restTimer);
        session.restTimer = null;
      }
    }

    function formatRestTime(seconds) {
      const total = Math.max(0, Math.trunc(Number(seconds) || 0));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}:${String(s).padStart(2, '0')}`;
    }

    function setRestUI() {
      const hint = $("tapHint");
      const meta = $("tapMeta");
      const count = $("curCount");
      if (!session.resting) {
        return;
      }
      if (count) count.textContent = formatRestTime(session.restRemaining);
      if (hint) hint.textContent = 'REST';
      if (meta) meta.textContent = 'Tap to skip rest';
    }

    function haptics(ms=40) {
      try { navigator.vibrate?.(ms); } catch {}
    }

    function stopSpeech() {
      try { window.speechSynthesis?.cancel(); } catch {}
      session.speakLocked = false;
    }

    let speechPrimed = false;
    function primeSpeech() {
      const synth = window.speechSynthesis;
      if (!synth || speechPrimed) return;
      try {
        const u = new SpeechSynthesisUtterance('ready');
        u.volume = 0; // inaudible primer to unlock iOS Safari
        u.rate = 1.0;
        u.pitch = 1.0;
        u.onend = () => { speechPrimed = true; };
        // Some iOS versions need a voice present before speak works
        const voices = synth.getVoices();
        if (voices && voices.length) u.voice = voices[0];
        synth.speak(u);
      } catch {
        speechPrimed = false;
      }
    }
    // Prime speech on first interaction to satisfy iOS user-gesture requirement
    ['pointerdown', 'touchstart', 'mousedown'].forEach((ev) => {
      window.addEventListener(ev, () => { primeSpeech(); }, { once: true, passive: true });
    });
    window.addEventListener('keydown', () => { primeSpeech(); }, { once: true });
    window.speechSynthesis?.addEventListener?.('voiceschanged', primeSpeech);

    function speak(text) {
      try {
        const synth = window.speechSynthesis;
        if (!synth || !text) return;
        if (!speechPrimed) primeSpeech();
        synth.cancel();
        const u = new SpeechSynthesisUtterance(String(text));
        u.rate = 1.0;
        u.pitch = 1.0;
        u.volume = 1.0;
        synth.speak(u);
      } catch {}
    }

    function maybeSpeakFinalCountdown() {
      if (!session.resting) return;
      if (session.restRemaining <= 5 && session.restRemaining > 0) {
        if (session.speakLocked) return;
        if (session.lastRestSpoken !== session.restRemaining) {
          // Lead with a cue when entering the final 5 seconds
          if ((session.lastRestSpoken === null || session.lastRestSpoken > 5) && session.restRemaining === 5) {
            session.speakLocked = true;
            try {
              const synth = window.speechSynthesis;
              if (synth) {
                synth.cancel();
                const u = new SpeechSynthesisUtterance('Get ready for the next set in 5');
                u.rate = 1.0;
                u.pitch = 1.0;
                u.volume = 1.0;
                u.onend = () => { session.speakLocked = false; };
                synth.speak(u);
              } else {
                session.speakLocked = false;
              }
            } catch {
              session.speakLocked = false;
            }
          } else {
            speak(session.restRemaining);
          }
          session.lastRestSpoken = session.restRemaining;
        }
      }
    }

    function attachSwipeRight(el, onSwipe, onProgress) {
      if (!el || typeof onSwipe !== 'function') return;
      let startX = 0;
      let startY = 0;
      let tracking = false;
      let activePointerId = null;
      const threshold = 110; // require a deliberate horizontal swipe
      const restraint = 70;  // allow small vertical drift only

      const report = (p) => {
        if (typeof onProgress === 'function') onProgress(Math.max(0, Math.min(1, p)));
      };

      const stop = () => {
        tracking = false;
        activePointerId = null;
        report(0);
      };

      if ('PointerEvent' in window) {
        el.addEventListener('pointerdown', (e) => {
          try { e.preventDefault(); } catch {}
          activePointerId = e.pointerId;
          startX = e.clientX;
          startY = e.clientY;
          tracking = true;
          report(0);
          try { el.setPointerCapture?.(activePointerId); } catch {}
        }, { passive: false });

        el.addEventListener('pointermove', (e) => {
          if (!tracking) return;
          if (activePointerId != null && e.pointerId !== activePointerId) return;
          try { e.preventDefault(); } catch {}
          const dy = Math.abs(e.clientY - startY);
          if (dy > restraint) {
            stop();
            return;
          }
          const dx = e.clientX - startX;
          report(dx > 0 ? dx / threshold : 0);
        }, { passive: false });

        el.addEventListener('pointerup', (e) => {
          if (activePointerId != null && e.pointerId !== activePointerId) return;
          try { e.preventDefault(); } catch {}
          const dx = e.clientX - startX;
          const dy = Math.abs(e.clientY - startY);
          if (tracking && dx >= threshold && dy <= restraint) {
            report(1);
            onSwipe();
            setTimeout(() => report(0), 120);
          } else {
            report(0);
          }
          tracking = false;
          try { el.releasePointerCapture?.(e.pointerId); } catch {}
          activePointerId = null;
        }, { passive: false });

        el.addEventListener('pointercancel', stop);
      } else {
        // Fallback for older Safari: touch events
        el.addEventListener('touchstart', (e) => {
          const t = e.touches && e.touches[0];
          if (!t) return;
          tracking = true;
          startX = t.clientX;
          startY = t.clientY;
          report(0);
          try { e.preventDefault(); } catch {}
        }, { passive: false });

        el.addEventListener('touchmove', (e) => {
          if (!tracking) return;
          const t = e.touches && e.touches[0];
          if (!t) return;
          try { e.preventDefault(); } catch {}
          const dy = Math.abs(t.clientY - startY);
          if (dy > restraint) {
            stop();
            return;
          }
          const dx = t.clientX - startX;
          report(dx > 0 ? dx / threshold : 0);
        }, { passive: false });

        el.addEventListener('touchend', (e) => {
          const t = (e.changedTouches && e.changedTouches[0]) || null;
          if (!t) { stop(); return; }
          try { e.preventDefault(); } catch {}
          const dx = t.clientX - startX;
          const dy = Math.abs(t.clientY - startY);
          if (tracking && dx >= threshold && dy <= restraint) {
            report(1);
            onSwipe();
            setTimeout(() => report(0), 120);
          } else {
            report(0);
          }
          tracking = false;
        }, { passive: false });

        el.addEventListener('touchcancel', stop);
      }

      // Avoid accidental click activation
      el.addEventListener('click', (e) => {
        try { e.preventDefault(); } catch {}
      });
    }

    function getAudioCtx() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
        if (audioCtx.state === 'suspended') audioCtx.resume();
        return audioCtx;
      } catch {
        return null;
      }
    }

    // Proactively unlock audio on first user interaction (iOS silent switch work-around)
    let audioUnlocked = false;
    function unlockAudioOnce() {
      if (audioUnlocked) return;
      const ctx = getAudioCtx();
      if (!ctx) return;
      Promise.resolve(ctx.resume?.()).then(() => {
        if (ctx.state !== 'running') return;
        audioUnlocked = true;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0.0001; // inaudible priming pulse
        osc.frequency.value = 440;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.02);
      }).catch(() => {});
    }
    ['pointerdown', 'touchstart', 'mousedown'].forEach((ev) => {
      window.addEventListener(ev, () => { unlockAudioOnce(); primeBeep(); }, { once: true, passive: true });
    });
    window.addEventListener('keydown', () => { unlockAudioOnce(); primeBeep(); }, { once: true });

    function playBeep() {
      const s = loadSettings();
      if (s.soundOn === false) return;
      // Respect the toggle immediately, even if user hasn't pressed “Save settings” yet.
      const toggle = $("beepToggle");
      if (toggle && toggle.checked === false) return;

      // Try HTMLMediaElement beep first (best chance to bypass iOS Silent)
      try {
        const el = getBeepEl();
        // Defensive: priming should restore these, but ensure beeps can never stay muted.
        el.muted = false;
        el.volume = 1.0;
        el.currentTime = 0;
        const p = el.play();
        // If it plays, add a light haptic too.
        Promise.resolve(p).then(() => haptics(10)).catch(() => {});
        return;
      } catch {}

      // Fallback: WebAudio oscillator (may be muted by iOS Silent)
      if (!audioUnlocked) unlockAudioOnce();
      const ctx = getAudioCtx();
      if (!ctx || ctx.state !== 'running') {
        haptics(40);
        return;
      }
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(880, now);
      gain.gain.setValueAtTime(0.18, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.14);
      osc.connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.16);
      haptics(12);
    }

    function renderSessionUI() {
      const i = session.curIndex;
      $("curSet").textContent = String(i + 1);
      $("curTarget").textContent = String(session.targets[i]);
      if (session.resting) {
        $("curCount").textContent = formatRestTime(session.restRemaining);
        $("tapHint").textContent = 'REST';
        $("tapMeta").textContent = 'Tap to skip rest';
      } else {
        const remaining = Math.max(0, (session.targets[i] || 0) - (session.actual[i] || 0));
        $("curCount").textContent = String(remaining);
        $("tapHint").textContent = 'TAP TO COUNT';
        $("tapMeta").textContent = 'Tap to count reps. During rest, the timer shows here—tap to skip.';
      }

      // strip
      const strip = $("targetStrip");
      strip.innerHTML = '';
      session.targets.forEach((t, idx) => {
        const pill = document.createElement('div');
        pill.className = 'setPill';
        pill.textContent = t;
        if (idx === i) pill.classList.add('active');
        if (session.actual[idx] > 0 && (idx < i || (idx === i && session.actual[idx] >= t))) pill.classList.add('done');
        strip.appendChild(pill);
      });

      setRestUI();

      // Disable tap while resting
      $("tapArea").style.opacity = session.resting ? '0.8' : '1';

      // Hide slider during rest; show it during active reps
      const finishBtn = $("finishSetBtn");
      if (finishBtn) finishBtn.style.display = session.resting ? 'none' : 'flex';
    }

    function restSecondsForSet(setIndex) {
      const settings = loadSettings();
      const targetReps = session.targets[setIndex] || 0;
      const actualReps = session.actual[setIndex] || 0;
      return getRestSeconds(setIndex, targetReps, actualReps, settings);
    }

    function startRest(seconds) {
      stopRestTimer();
      const s = loadSettings();
      const base = Number.isFinite(seconds) ? seconds : s.baseRestSeconds || 90;
      session.resting = true;
      session.restRemaining = clampInt(Number(base || s.baseRestSeconds || 90), s.minRestSeconds, s.maxRestSeconds);
      session.lastRestSpoken = null;
      session.speakLocked = false;
      stopSpeech();
      renderSessionUI();
      haptics(60);
      maybeSpeakFinalCountdown();

      session.restTimer = setInterval(() => {
        if (session.speakLocked) {
          setRestUI();
          return;
        }
        session.restRemaining -= 1;
        maybeSpeakFinalCountdown();
        if (session.restRemaining <= 0) {
          stopRestTimer();
          session.resting = false;
          session.restRemaining = 0;
          session.lastRestSpoken = null;
          session.speakLocked = false;
          stopSpeech();
          renderSessionUI();
          haptics(120);
          return;
        }
        setRestUI();
      }, 1000);
    }

    function skipRest() {
      if (!session.resting) return;
      if (session.restRemaining > 5) {
        session.restRemaining = 5;
        session.lastRestSpoken = null;
        session.speakLocked = false;
        renderSessionUI();
        maybeSpeakFinalCountdown();
        haptics(60);
        return;
      }
      stopRestTimer();
      session.resting = false;
      session.restRemaining = 0;
      session.lastRestSpoken = null;
      session.speakLocked = false;
      stopSpeech();
      renderSessionUI();
    }

    function maybeAutoAdvance() {
      const i = session.curIndex;
      const target = session.targets[i];
      const done = session.actual[i] >= target;
      if (!done) return;

      // If last set, finish session
      if (i >= 4) {
        finishSession();
        return;
      }

      const restSeconds = restSecondsForSet(i);

      // Advance to next set and start rest
      session.curIndex += 1;
      renderSessionUI();
      startRest(restSeconds);
    }

    function incRep(delta) {
      if (!session.active) return;
      if (session.resting) return;
      const i = session.curIndex;
      const prev = session.actual[i];
      session.actual[i] = clampInt(session.actual[i] + delta, 0, 999);
      if (session.actual[i] > prev && delta > 0) playBeep();
      const remaining = Math.max(0, (session.targets[i] || 0) - (session.actual[i] || 0));
      $("curCount").textContent = String(remaining);
      haptics(20);
      // lightweight render: only fully render when reaching target or correcting below
      if (session.actual[i] === session.targets[i]) {
        renderSessionUI();
        maybeAutoAdvance();
      } else {
        // Update strip done state occasionally
        if (session.actual[i] > session.targets[i] || session.actual[i] === 0) renderSessionUI();
      }
    }

    function finishSetManual() {
      if (!session.active) return;
      if (session.resting) return;
      const completedIndex = session.curIndex;
      // Treat current count as final and advance
      if (session.curIndex >= 4) {
        finishSession();
        return;
      }
      const restSeconds = restSecondsForSet(completedIndex);
      session.curIndex += 1;
      renderSessionUI();
      startRest(restSeconds);
    }

    function startSession() {
      const settings = loadSettings();
      const date = currentDate || isoToday();
      currentDate = date;

      session.active = true;
      session.date = date;
      session.day = loadProgressDay(settings.totalDays);

      const target = generateTargetForDay(session.day, settings);
      session.targets = [...target.sets];
      session.actual = [0,0,0,0,0];
      session.curIndex = 0;
      session.resting = false;
      session.restRemaining = 0;
      stopRestTimer();

      renderSessionUI();
    }

    function finishSession() {
      stopRestTimer();
      session.resting = false;

      const date = session.date || currentDate || isoToday();
      const settings = loadSettings();
      const day = loadProgressDay(settings.totalDays);
      const sets = [...session.actual];
      const total = sets.reduce((a, b) => a + b, 0);

      const targetPlan = generateTargetForDay(day, settings);
      const success = sets.length === targetPlan.sets.length && sets.every((rep, idx) => rep >= (targetPlan.sets[idx] || 0));

      // Persist workout automatically
      const w = { date, day, sets, total };
      const workouts = upsertWorkout(loadWorkouts(), w);
      saveWorkouts(workouts);

      // Advance progression only if all targets met
      if (success) {
        setProgressDay(Math.min(day + 1, settings.totalDays), settings.totalDays);
      }

      // Update UI
      currentDate = date;
      renderWorkoutView();
      renderHistoryView();

      // Reflect completion badges immediately
      $("setsDisplay").textContent = sets.join(" / ");
      $("todayTotal").textContent = String(total);
      $("doneChip").innerHTML = '<ion-label>Done: Yes</ion-label>';
      $("doneChip").className = 'chipOk ion-color ion-color-success';

      session.active = false;

      toast('Session saved');
      try {
        const line = MOTIVATION_LINES[Math.floor(Math.random() * MOTIVATION_LINES.length)] || '';
        if (line) speak(line);
      } catch {}
      dismissOverlay(window._trainingModal);
      haptics(120);
    }

    // -----------------------------
    // Max single-set test
    // -----------------------------
    function renderMaxUI() {
      $("maxCount").textContent = String(maxSession.count);
    }

    function incMax(delta) {
      if (!maxSession.active) return;
      const prev = maxSession.count;
      maxSession.count = clampInt(maxSession.count + delta, 0, 9999);
      if (delta > 0 && maxSession.count > prev) playBeep();
      renderMaxUI();
      haptics(20);
    }

    function startMaxTest() {
      maxSession.active = true;
      maxSession.count = 0;
      renderMaxUI();
    }

    function finishMaxTest() {
      if (!maxSession.active) return;
      maxSession.active = false;
      const best = loadMaxSingle();
      const next = Math.max(best, maxSession.count);
      saveMaxSingle(next);
      $("maxBest").textContent = String(next || "—");
      toast(next > best ? 'New max saved' : 'Saved');
      dismissOverlay(window._maxModal);
    }

    // -----------------------------
    // Self-tests
    // -----------------------------
    function runSelfTests() {
      const settings = loadSettings();

      const s1 = { ...settings, startMax: 30, goalMax: 100, rounding: 'nearest' };
      const t1 = generateTargetForDay(1, s1);
      if (t1.sets.length !== 5 || t1.sets[0] < t1.sets[1]) {
        console.warn('Self-test failed: monotonic sets', t1.sets);
      }

      // Session advance test
      const tmp = {
        active: true,
        targets: [2,2,2,2,2],
        actual: [0,0,0,0,0],
        curIndex: 0,
        resting: false
      };
      if (tmp.targets.length !== 5) console.warn('Self-test failed: targets length');
    }

    // -----------------------------
    // Wire up events
    // -----------------------------
    window.addEventListener('load', async () => {
      await ensureDefined('ion-modal');
      await ensureDefined('ion-toast');
      await ensureDefined('ion-alert');

      const settingsModal = $("settingsModal");
      const trainingModal = $("trainingModal");
      const recordModal = $("recordModal");
      const planModal = $("planModal");
      const maxModal = $("maxModal");
      window._trainingModal = trainingModal;
      window._maxModal = maxModal;

      await Promise.all([ready(settingsModal), ready(trainingModal), ready(recordModal), ready(planModal), ready(maxModal)]);

      // Always track today's date at startup
      currentDate = isoToday();

      const s = loadSettings();
      $("maxReps").value = s.startMax ?? s.maxReps;
      $("startPercent").value = '—';
      $("startPercent").disabled = true;
      $("drops").value = '85,80,75,70,65';
      $("drops").disabled = true;
      $("rest").value = s.baseRestSeconds;
      $("beepToggle").checked = s.soundOn !== false;
      $("planDays").value = s.totalDays;
      $("goalVolume").value = s.goalMax;
      $("rounding").value = s.rounding;

      runSelfTests();
      renderWorkoutView();
      renderHistoryView();

      $("tabSeg").addEventListener('ionChange', (e) => switchTab(e.detail.value));

      $("settingsBtn").addEventListener('click', () => presentOverlay(settingsModal));
      $("closeSettings").addEventListener('click', () => dismissOverlay(settingsModal));

      // Start training: opens full session UI
      $("startTrainingBtn").addEventListener('click', async () => {
        if (!currentDate) currentDate = isoToday();
        startSession();
        await presentOverlay(trainingModal);
      });

      // Close training
      $("closeTraining").addEventListener('click', async () => {
        // Do not lose counts accidentally
        const alert = document.createElement('ion-alert');
        alert.cssClass = 'dark-alert';
        alert.header = 'End session?';
        alert.message = 'Your current session progress will be kept (not saved) unless you finish it.';
        alert.buttons = [
          { text: 'Cancel', role: 'cancel' },
          {
            text: 'End',
            role: 'destructive',
            handler: () => {
              stopRestTimer();
              session.active = false;
              session.resting = false;
              session.restRemaining = 0;
              dismissOverlay(trainingModal);
            }
          }
        ];
        document.body.appendChild(alert);
        await presentOverlay(alert);
        alert.addEventListener('didDismiss', () => alert.remove());
      });

      // Tap / click to count
      const tapArea = $("tapArea");
      const tapHandler = (e) => {
        e.preventDefault();
        if (session.resting) {
          skipRest();
          return;
        }
        incRep(1);
        // Auto-advance if above target too
        maybeAutoAdvance();
      };
      // pointerdown for immediacy; avoid double-fire by skipping click
      tapArea.addEventListener('pointerdown', tapHandler);

      // Slide-to-finish (true "slide to unlock" drag) — implemented with pointer capture for iOS reliability.
      const finishBtn = $("finishSetBtn");
      const finishThumb = finishBtn?.querySelector('.swipeKnob') || null;
      const finishFill = finishBtn?.querySelector('.swipeFill') || null;
      const finishLabel = finishBtn?.querySelector('.swipeLabel') || null;
      let finishSlidingLocked = false;

      const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
      const layoutFinish = () => {
        const rect = finishBtn?.getBoundingClientRect();
        const w = rect?.width || 0;
        const knobW = 44;
        const leftPad = 10;
        const rightPad = 10;
        const maxX = Math.max(0, w - leftPad - knobW - rightPad);
        return { maxX, knobW, leftPad, rightPad };
      };
      const setFinishX = (x, { animate = false } = {}) => {
        if (!finishBtn || !finishThumb || !finishFill) return;
        finishThumb.style.transition = animate ? 'transform 180ms ease' : 'none';
        finishFill.style.transition = animate ? 'width 180ms ease' : 'none';
        finishThumb.style.transform = `translate(${Math.round(x)}px, -50%)`;
        const { knobW, leftPad } = layoutFinish();
        finishFill.style.width = `${Math.round(x + knobW + leftPad)}px`;
      };

      // initialize visuals
      setFinishX(0, { animate: false });

      if (finishThumb && finishBtn) {
        let activePointerId = null;
        let startX = 0;
        let startY = 0;
        let baseX = 0;

        const onDown = (clientX, clientY) => {
          if (finishSlidingLocked) return;
          activePointerId = activePointerId ?? 0;
          startX = clientX;
          startY = clientY;
          baseX = 0;
          finishThumb.style.transition = 'none';
          finishFill.style.transition = 'none';
        };

        const onMove = (clientX, clientY) => {
          if (finishSlidingLocked) return;
          const dy = Math.abs(clientY - startY);
          if (dy > 70) {
            if (finishLabel) finishLabel.textContent = 'Swipe right to finish set.';
            setFinishX(0, { animate: true });
            activePointerId = null;
            return;
          }
          const { maxX } = layoutFinish();
          const dx = clientX - startX;
          const x = clamp(baseX + dx, 0, maxX);
          setFinishX(x, { animate: false });
          const progress = maxX ? x / maxX : 0;
          if (finishLabel) finishLabel.textContent = progress > 0.95 ? 'Release to finish' : 'Swipe right to finish set.';
        };

        const onEnd = (clientX, clientY) => {
          if (finishSlidingLocked) return;
          const { maxX } = layoutFinish();
          const dx = clientX - startX;
          const x = clamp(baseX + dx, 0, maxX);
          const progress = maxX ? x / maxX : 0;

          if (progress >= 0.92) {
            finishSlidingLocked = true;
            if (finishLabel) finishLabel.textContent = 'Finishing…';
            setFinishX(maxX, { animate: true });

            if (session.active && !session.resting) {
              finishSetManual();
              haptics(50);
            }

            setTimeout(() => {
              setFinishX(0, { animate: true });
              if (finishLabel) finishLabel.textContent = 'Swipe right to finish set.';
              finishSlidingLocked = false;
            }, 450);
          } else {
            if (finishLabel) finishLabel.textContent = 'Swipe right to finish set.';
            setFinishX(0, { animate: true });
          }

          activePointerId = null;
        };

        if ('PointerEvent' in window) {
          finishThumb.addEventListener('pointerdown', (e) => {
            if (finishSlidingLocked) return;
            try { e.preventDefault(); } catch {}
            activePointerId = e.pointerId;
            startX = e.clientX;
            startY = e.clientY;
            baseX = 0;
            try { finishThumb.setPointerCapture?.(activePointerId); } catch {}
            finishThumb.style.transition = 'none';
            finishFill.style.transition = 'none';
          }, { passive: false });

          finishThumb.addEventListener('pointermove', (e) => {
            if (activePointerId == null) return;
            if (e.pointerId !== activePointerId) return;
            try { e.preventDefault(); } catch {}
            onMove(e.clientX, e.clientY);
          }, { passive: false });

          const endPtr = (e) => {
            if (activePointerId == null) return;
            if (e.pointerId !== activePointerId) return;
            try { e.preventDefault(); } catch {}
            onEnd(e.clientX, e.clientY);
            try { finishThumb.releasePointerCapture?.(e.pointerId); } catch {}
          };
          finishThumb.addEventListener('pointerup', endPtr, { passive: false });
          finishThumb.addEventListener('pointercancel', endPtr, { passive: false });
        } else {
          // Touch fallback
          finishThumb.addEventListener('touchstart', (e) => {
            if (finishSlidingLocked) return;
            const t = e.touches && e.touches[0];
            if (!t) return;
            try { e.preventDefault(); } catch {}
            onDown(t.clientX, t.clientY);
          }, { passive: false });
          finishThumb.addEventListener('touchmove', (e) => {
            const t = e.touches && e.touches[0];
            if (!t) return;
            try { e.preventDefault(); } catch {}
            onMove(t.clientX, t.clientY);
          }, { passive: false });
          finishThumb.addEventListener('touchend', (e) => {
            const t = (e.changedTouches && e.changedTouches[0]) || null;
            if (!t) return;
            try { e.preventDefault(); } catch {}
            onEnd(t.clientX, t.clientY);
          }, { passive: false });
          finishThumb.addEventListener('touchcancel', () => {
            if (finishLabel) finishLabel.textContent = 'Swipe right to finish set.';
            setFinishX(0, { animate: true });
            activePointerId = null;
          }, { passive: false });
        }

        // Prevent clicks from triggering anything
        finishBtn.addEventListener('click', (e) => {
          try { e.preventDefault(); } catch {}
        });
      }

      // Record modal
      $("sessionBtn").addEventListener('click', async () => {
        const best = loadWorkouts().reduce((m, w) => Math.max(m, w.total || 0), 0);
        $("prNumber").textContent = best ? String(best) : "—";
        const sPlan = loadSettings();
        $("prGoalBadge").textContent = String(sPlan.goalMax || 100);
        $("maxBest").textContent = String(loadMaxSingle() || "—");
        await presentOverlay(recordModal);
      });
      $("closeRecord").addEventListener('click', () => dismissOverlay(recordModal));

      $("startMaxBtn").addEventListener('click', async () => {
        startMaxTest();
        await presentOverlay(maxModal);
      });
      $("closeMax").addEventListener('click', () => dismissOverlay(maxModal));
      $("finishMaxBtn").addEventListener('click', () => finishMaxTest());
      $("maxTapArea").addEventListener('pointerdown', (e) => { e.preventDefault(); incMax(1); });

      $("viewPlanBtn").addEventListener('click', async () => {
        renderPlanList();
        await presentOverlay(planModal);
      });
      $("closePlan").addEventListener('click', () => dismissOverlay(planModal));

      // Save settings
      $("saveSettingsBtn").addEventListener('click', () => {
        const startMax = Number($("maxReps").value);
        const baseRestSeconds = Number($("rest").value);
        const totalDays = Number($("planDays").value);
        const goalMax = Number($("goalVolume").value);
        const rounding = $("rounding").value;
        const soundOn = Boolean($("beepToggle").checked);

        if (!Number.isFinite(startMax) || startMax < 1) return toast('maxReps must be >= 1');
        if (!Number.isFinite(baseRestSeconds) || baseRestSeconds < 10) return toast('Rest seconds must be >= 10');
        if (!Number.isFinite(totalDays) || totalDays < 1 || totalDays > 365) return toast('Plan days must be 1-365');
        if (!Number.isFinite(goalMax) || goalMax < 1 || goalMax > 100000) return toast('Goal max must be 1-100000');

        const cur = loadSettings();
        saveSettings({
          ...cur,
          startMax,
          maxReps: startMax,
          goalMax,
          intensityProfile: [0.85, 0.80, 0.75, 0.70, 0.65],
          baseRestSeconds,
          restSeconds: baseRestSeconds,
          totalDays,
          goalMax,
          rounding,
          soundOn
        });
        toast('Settings saved');
        renderWorkoutView();
        renderHistoryView();
      });

      // Reset plan
      $("startTodayBtn").addEventListener('click', () => {
        setStartDate(isoToday());
        currentDate = isoToday();
        setProgressDay(1, loadSettings().totalDays);
        toast('Plan reset to today (Day 1)');
        renderWorkoutView();
        renderHistoryView();
      });

      // Export
      $("exportBtn").addEventListener('click', () => {
        const payload = {
          settings: loadSettings(),
          startDate: loadStartDate(),
          workouts: loadWorkouts(),
          maxSingle: loadMaxSingle(),
          exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `pushup100-backup-${isoToday()}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
        toast('Exported JSON');
      });

      // Import
      $("importBtn").addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = async () => {
          const file = input.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            const payload = JSON.parse(text);
            if (payload.settings) saveSettings(payload.settings);
            if (payload.startDate) setStartDate(payload.startDate);
            if (Array.isArray(payload.workouts)) saveWorkouts(payload.workouts);
            if (Number.isFinite(payload.maxSingle)) saveMaxSingle(payload.maxSingle);
            toast('Imported');
            renderWorkoutView();
            renderHistoryView();
          } catch {
            toast('Import failed');
          }
        };
        input.click();
      });

      // Wipe
      $("wipeBtn").addEventListener('click', async () => {
        const alert = document.createElement('ion-alert');
        alert.cssClass = 'dark-alert';
        alert.header = 'Wipe all data?';
        alert.message = 'This deletes workouts and settings from this device.';
        alert.buttons = [
          { text: 'Cancel', role: 'cancel' },
          {
            text: 'Wipe',
            role: 'destructive',
            handler: () => {
              localStorage.removeItem(KEY_SETTINGS);
              localStorage.removeItem(KEY_START_DATE);
              localStorage.removeItem(KEY_WORKOUTS);
              localStorage.removeItem(KEY_MAX_SINGLE);
              localStorage.removeItem(KEY_PROGRESS_DAY);
              toast('Wiped');

              const s2 = loadSettings();
              $("maxReps").value = s2.startMax ?? s2.maxReps;
              $("startPercent").value = '—';
              $("drops").value = '85,80,75,70,65';
              $("rest").value = s2.baseRestSeconds;
              $("beepToggle").checked = s2.soundOn !== false;
              $("planDays").value = s2.totalDays;
              $("goalVolume").value = s2.goalMax;
              $("rounding").value = s2.rounding;
              currentDate = isoToday();
              setProgressDay(1, s2.totalDays);
              $("maxBest").textContent = '—';

              renderWorkoutView();
              renderHistoryView();
            }
          }
        ];
        document.body.appendChild(alert);
        await presentOverlay(alert);
        alert.addEventListener('didDismiss', () => alert.remove());
      });
    });
  </script>
</body>
</html>

